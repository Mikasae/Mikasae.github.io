<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>利用Cheverto搭建图床</title>
      <link href="2021/07/01/14Cheverto%E5%9B%BE%E5%BA%8A/"/>
      <url>2021/07/01/14Cheverto%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>官网：<a href="https://chevereto.com/">https://chevereto.com/</a></p><p>官方文档：<a href="https://ch.cndrew.cn/">https://ch.cndrew.cn/</a></p></blockquote><h2 id="0x01-Cheverto介绍"><a href="#0x01-Cheverto介绍" class="headerlink" title="0x01 Cheverto介绍"></a>0x01 Cheverto介绍</h2><ul><li>Cheverto是一款自建图床程序，可以使用Cheverto在自己的服务器上搭建自己的图床</li><li>分为免费版和收费版，但是免费版本已经足够我们使用了，付费版多了硬盘扩展(图片极多的时候有用)和社交分享的功能，而且可以通过宝塔的硬盘挂载实现扩展功能。</li><li>详情参考官网介绍</li></ul><h2 id="0x02-安装"><a href="#0x02-安装" class="headerlink" title="0x02 安装"></a>0x02 安装</h2><blockquote><p>根目录下进行操作</p></blockquote><h3 id="1-搭建Web环境"><a href="#1-搭建Web环境" class="headerlink" title="1. 搭建Web环境"></a>1. 搭建Web环境</h3><p>使用宝塔进行一键部署【因为环境以前就有，因此无法做过多赘述】,有域名的将网站的域名解析也弄好（ps:后续操作建议使用宝塔，便捷）</p><h3 id="2-上传Chevereto程序"><a href="#2-上传Chevereto程序" class="headerlink" title="2. 上传Chevereto程序"></a>2. 上传Chevereto程序</h3><p>根据<a href="https://github.com/Chevereto/Chevereto-Free">下载链接</a>下载程序，上传至服务器网站的根目录</p><blockquote><p>以下操作利用宝塔面板和FinalShell工具完成，因此很多都是界面化操作未使用命令行，例如服务器下载程序是使用wegt的命令，我就直接在Windwos上下载下来了然后用finalshell上传的</p><p><img src="https://cdn.jsdelivr.net/gh/Mikasae/Mikasa/boke/21.7.1-14%20(12).png" alt="image-20210701203306274"></p></blockquote><p>然后解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zfvx Chevereto-Free-1.3.0.tar.gz</span><br></pre></td></tr></table></figure><p>之后将解压后Chevereto-Free-1.3.0文件夹的内容全部剪切到根目录下</p><p>修改content、images、app\install\temp这几个文件夹的权限为777，主要是写权限</p><blockquote><p>如果后续过程中提示哪个文件夹的writing有问题，那就需要按照提示修改对应的权限即可</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Mikasae/Mikasa/boke/21.7.1-14%20(2).png" alt="image-20210701204104404"></p><p>然后在宝塔面板中为网站添加伪静态规则</p><blockquote><p>有些添加至伪静态下面的配置文件中也可以，我添加至配置文件中打开网址会提示Niginx 404</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php?<span class="variable">$query_string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://cdn.jsdelivr.net/gh/Mikasae/Mikasa/boke/21.7.1-14%20(1).png" alt="image-20210701203705700"></p></blockquote><p>最后在解压后的app文件夹中创建settings.php文件</p><p>往文件夹内写入以下内容，（数据库需要提前下载好）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$settings</span> = <span class="keyword">array</span> (</span><br><span class="line">  <span class="string">&#x27;db_host&#x27;</span> =&gt; <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;db_name&#x27;</span> =&gt; <span class="string">&#x27;数据库名字&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;db_user&#x27;</span> =&gt; <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;db_pass&#x27;</span> =&gt; <span class="string">&#x27;用户密码&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;db_table_prefix&#x27;</span> =&gt; <span class="string">&#x27;chv_&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;db_driver&#x27;</span> =&gt; <span class="string">&#x27;mysql&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;db_pdo_attrs&#x27;</span> =&gt; </span><br><span class="line">  <span class="keyword">array</span> (</span><br><span class="line">  ),</span><br><span class="line">  <span class="string">&#x27;debug_level&#x27;</span> =&gt; <span class="number">1</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>打开网站时若出现Chevereto can’t create the app/settings.php file. You must manually create this file这个报错，那就是因为没有settings这个文件。</p><p>创建好这个文件后可以不写这些内容，那么在后续打开网站时会要你手动输入</p></blockquote><h2 id="3-网址测试"><a href="#3-网址测试" class="headerlink" title="3. 网址测试"></a>3. 网址测试</h2><p>上述步骤做完后便可以打开网址了，打开后自动跳转至设置界面，设置注册后图床便搭建好了</p><p><img src="https://cdn.jsdelivr.net/gh/Mikasae/Mikasa/boke/21.7.1-14%20(3).png" alt="image-20210701204849547"></p><p>后台界面</p><p><img src="https://cdn.jsdelivr.net/gh/Mikasae/Mikasa/boke/21.7.1-14%20(10).png" alt="image-20210701213545966"></p><h2 id="0x03-API使用"><a href="#0x03-API使用" class="headerlink" title="0x03 API使用"></a>0x03 API使用</h2><p>我搭建图床的目的是为另一个博客，因此便需要使用到图床的API接口</p><p>首先打开<a href="https://ch.cndrew.cn/cn/API/API/">官方文档</a>,通过官方文档可以找到大致操作和介绍</p><p>调用API需要使用到API密匙(仪表盘–&gt;设置–&gt;API)</p><p><img src="https://cdn.jsdelivr.net/gh/Mikasae/Mikasa/boke/21.7.1-14%20(4).png" alt="image-20210701205438424"></p><p>API请求的参数官方文档中有详细介绍，如下</p><p><img src="https://cdn.jsdelivr.net/gh/Mikasae/Mikasa/boke/21.7.1-14%20(5).png" alt="image-20210701205704833"></p><p>我们上传调用使用到的参数就是：upload,key,source，format格式参数默认就是json</p><p>下面是一个请求示例，这里直接使用了get请求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//网址/api/1/upload/?key=API密匙&amp;source=https://mikasae.github.io/Mikasa/RemMikasa/diary/6.30.2.png</span></span><br></pre></td></tr></table></figure><p>返回的一部分参数</p><p><img src="https://cdn.jsdelivr.net/gh/Mikasae/Mikasa/boke/21.7.1-14%20(6).png" alt="image-20210701210025126"></p><h2 id="0x04-注意和报错"><a href="#0x04-注意和报错" class="headerlink" title="0x04 注意和报错"></a>0x04 注意和报错</h2><h3 id="1-mysql"><a href="#1-mysql" class="headerlink" title="1. mysql"></a>1. mysql</h3><p>此图床是需要使用到mysql的，在settings.php中设置的也就是mysql创建的数据库相关信息，因此配置时要提前创建好数据库</p><h3 id="2-php版本"><a href="#2-php版本" class="headerlink" title="2. php版本"></a>2. php版本</h3><p>有时候如果报一些php的相关错误，可能是php版本的问题，我在安装时使用php8.0时报了很多错，切换成php7.4便没有问题了</p><h3 id="3-缺少session-save-path"><a href="#3-缺少session-save-path" class="headerlink" title="3. 缺少session.save_path"></a>3. 缺少session.save_path</h3><p>在打开网站时报错:（一般在报错的最后一句）</p><p>g: sessions are not working on this server due to missing write permission on session save path (php.ini session.save_path).</p><p>解决办法：在宝塔文件中搜索php.ini文件，找到打开后Ctrl+F搜索session.save_path，如果找到就将前面的注释取消，未找到就添加session.save_path = “tmp”</p><p>详情请参考<a href="https://23232333.com/2021/06/06/%E3%80%90%E8%87%AA%E5%BB%BA%E5%9B%BE%E5%BA%8A%E3%80%91%E9%80%9A%E8%BF%87%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8Achevereto%E5%9B%BE%E5%BA%8A%E7%A8%8B%E5%BA%8F%E6%90%AD/">通过宝塔面板搭建图床|Chevereto图床程序搭建教程</a></p><h3 id="4-目录问题"><a href="#4-目录问题" class="headerlink" title="4. 目录问题"></a>4. 目录问题</h3><p>整套安装建议在根目录下进行操作(就是前面说的解压后将所有文件放在根目录)，可以避免一些不必要的问题，如果实在不想根目录下乱的话可以在安装完成后再将所有文件整理到一个文件夹中，使用Apache比Nginx更容易</p><blockquote><p>一开始我是未使用根目录的，上面出现的问题我挨个碰了个遍，解决后还是有莫名其妙的问题，就直接全部换成根目录重新操作了一遍，中间未遇到任何问题(没想明白)</p></blockquote><blockquote><p>若有问题或者因为表述不清未看明白的欢迎直接咨询博主或留言</p></blockquote><h2 id="0x05-ImgUrl图床"><a href="#0x05-ImgUrl图床" class="headerlink" title="0x05 ImgUrl图床"></a>0x05 ImgUrl图床</h2><p>imgUrl也是一款简单纯粹的图床程序，加上Cheverto，这两个图床程序是比较好用的，我因为使用的是Cheverto搭建的图床，因此imgUrl只在本地进行了搭建测试，最后有界面展示。</p><p>imgUrl搭建还是比较简单的，只要提前将需要的插件(fileinfo &amp; imagemagick)和环境配好，直接下载程序解压就可以打开网站使用了，会自动进行引导安装的界面.</p><p>插件的话有宝塔，点两下就可以了，然后如果用的是Apache，伪静态都不需要设置，直接解压，over.</p><p><img src="https://cdn.jsdelivr.net/gh/Mikasae/Mikasa/boke/21.7.1-14%20(7).png" alt="image-20210701213353267"></p><p><img src="https://cdn.jsdelivr.net/gh/Mikasae/Mikasa/boke/21.7.1-14%20(8).png" alt="image-20210701213421716"></p><p><img src="https://cdn.jsdelivr.net/gh/Mikasae/Mikasa/boke/21.7.1-14%20(9).png" alt="image-20210701213454582"></p>]]></content>
      
      
      <categories>
          
          <category> 图床 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cheverto </tag>
            
            <tag> 广度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实训Day05</title>
      <link href="2021/05/28/13%E5%AE%9E%E8%AE%ADDay05/"/>
      <url>2021/05/28/13%E5%AE%9E%E8%AE%ADDay05/</url>
      
        <content type="html"><![CDATA[<h1 id="Zigbee通信"><a href="#Zigbee通信" class="headerlink" title="Zigbee通信"></a>Zigbee通信</h1><blockquote><p>这篇文章就是将末尾的PPT重新复制到了文章之中，别问，问就是懒</p></blockquote><h2 id="0x01无线通信"><a href="#0x01无线通信" class="headerlink" title="0x01无线通信"></a>0x01无线通信</h2><h3 id="1-无线通信理论"><a href="#1-无线通信理论" class="headerlink" title="1.无线通信理论"></a>1.无线通信理论</h3><ul><li><p>Zigbee无线通信，需要高频的载波来提供发射频率，Zigbee模块之间要可以正常通信，接收模块和发送模块的频率要一致。</p></li><li><p>Zigbee有27个载波可以进行通信，载波又叫做信道。这些载波的频率落在某些频率区段，我们把这些区段叫做频段。</p><blockquote><p>2.4G频段            16个信道</p><p> 915M频段   896M频段  11个信道</p><p>但TI的所有支持Zigbee底层协议的芯片只能在2.4G频段的16个信道里进行通信。即11<del>26信道(0</del>10信道在915M和896M的频段内)</p></blockquote></li><li><p>网络地址</p><ul><li>在Zigbee无线局域网里，每一个模块都有一个在该网络里唯一的2个字节的地址，这个地址我们叫做网络地址(或者叫做网络短地址)。</li></ul></li><li><p>PANID</p><ul><li>这也是一个2个字节的编号，用来区分不用的Zigbee无线局域网，我们称为个域网ID。两个模块之间要进行通信，PANID一定要一样。</li></ul></li><li><p>信道与PANID的设置</p><ul><li><p>在Tools文件组里的f8wConfig.cfg文件中</p></li><li><p>(1)设置信道</p><blockquote><p>-DDEFAULT_CHANLIST=0x00000800 // 11 - 0x0B</p></blockquote></li><li><p>(2)设置PANID</p><blockquote><p> -DZDAPP_CONFIG_PAN_ID=0x1234</p></blockquote><blockquote><p>注意:如果把PANID设置为0xFFFF,则意味着该模块不受PANID的限制</p></blockquote></li></ul></li></ul><h3 id="2-网络组建理论"><a href="#2-网络组建理论" class="headerlink" title="2.网络组建理论"></a>2.网络组建理论</h3><ul><li><p>在Zigbee无线局域网里，节点(无线模块)按照在网络里的功能可以划分为:协调器、路由器、终端这三种角色</p></li><li><p>它们的硬件可以是一模一样的，之所以在网络里表现出不同的功能，是因为它们下载了不同功能版本的程序，在同一个网络里担当了不同的角色功能。</p><blockquote><p><img src="../../../../../%E5%9B%BE%E7%89%87/%E8%B5%84%E6%96%99/01Typora%E4%BF%9D%E5%AD%98/image-20210531092938956.png" alt="image-20210531092938956"></p></blockquote></li><li><p>下载了路由器和终端代码的模块，它们上电后的第一件事情去寻找网络，请求加入。然而网络不会无缘无故产生，是由下载了协调器代码的模块创建的。</p></li><li><p>下载了协调器代码的模块上电后的第一件事就是创建网络。</p></li><li><p>任何一个网络里，第一个节点一定是该网络的协调器，有且只能有一个协调器</p></li><li><p>任何一个Zigbee模块要加入到某个网络，一定要一个处于该网络里的节点作为介绍人，并且这个介绍人不能是终端节点(即路由器或者协调器)。在加入网络以后，介绍人节点和被介绍加入的节点互为父子关系。</p></li><li><p>介绍人是被介绍人的父节点，被介绍人是介绍人的、子节点。有多个可作为介绍人资格的节点，会选择信号强度高的节点作为介绍人。</p></li><li><p>协调器在创建完网络后，在网络里的功能与路由器没有任何区别，只不过协调器的网络地址比较特殊只能是0x0000，而其他加入的节点的网络地址是动态分配的。</p></li><li><p>终端节点与其他模块的通信必须要通过它的父节点，而路由器(协调器)之间通信可以直接通信的。</p></li><li><p>因此，<strong>路由器在网络里充当的是拓扑扩展的中转站的功能</strong>。</p></li><li><p>综合</p><ul><li>我们可以在GenericApp.c文件中的GenericApp_ProcessEvent函数中的switch语句的 case ZDO_STATE_CHANGE中修改代码内容，让模块在不同的网络状态下亮不同的灯。</li><li>注意:下载了协调器的代码的模块，创建了网络之后就是协调器状态，而终端和路由器要加入了网络才是对应的状态。终端和路由器要加入网络的条件是，信道和PANID要一致。</li></ul></li></ul><h3 id="3-三种网络架构"><a href="#3-三种网络架构" class="headerlink" title="3.三种网络架构"></a>3.三种网络架构</h3><ol><li><p>星形拓扑</p><ul><li><p>星形拓扑是最简单的一种拓扑形式，他包含一个Co-ordinator（协调者） 节点和一系列的 End Device（终端）节点。每一个End Device 节点只能和 Co-ordinator 节点进行通讯。如果需要在两个 End Device 节点之间进行通讯必须通过Co-ordinator 节点进行信息的转发。</p><blockquote><p><img src="../../../../../%E5%9B%BE%E7%89%87/%E8%B5%84%E6%96%99/01Typora%E4%BF%9D%E5%AD%98/image-20210531093356279.png" alt="image-20210531093356279"></p></blockquote></li></ul></li><li><p>树形拓扑</p><ul><li><p>树形拓扑包括一个Co-ordinator（协调者）以及一系列的 Router（路由器） 和 End Device（终端）节点。Co-ordinator 连接一系列的 Router 和 End Device， 他的子节点的 Router也可以连接一系列的 Router 和End Device. 这样可以重复多个层级。</p><blockquote><p><img src="../../../../../%E5%9B%BE%E7%89%87/%E8%B5%84%E6%96%99/01Typora%E4%BF%9D%E5%AD%98/image-20210531093438391.png" alt="image-20210531093438391"></p></blockquote></li></ul></li><li><p>Mesh拓扑（网状拓扑） </p><ul><li><p>包含一个Co-ordinator和一系列的Router 和End Device。这种网络拓扑形式和树形拓扑相同；请参考上面所提到的树形网络拓扑。但是，网状网络拓扑具有更加灵活的信息路由规则，在可能的情况下，路由节点之间可以直接的通讯。这种路由机制使得信息的通讯变得更有效率，而且意味这一旦一个路由路径出现了问题，信息可以自动的沿着其他的路由路径进行传输。 网状拓扑的示意图如下所示：</p><blockquote><p><img src="../../../../../%E5%9B%BE%E7%89%87/%E8%B5%84%E6%96%99/01Typora%E4%BF%9D%E5%AD%98/image-20210531093511344.png" alt="image-20210531093511344"></p></blockquote></li></ul></li><li><p>架构比较</p><ul><li><p>MESH 网状网络拓扑结构的网络具有强大的功能，网络可以通过“多级跳”的方式来通信；该拓扑结构还可以组成极为复杂的网络；网络还具备自组织、自愈功能；</p></li><li><p>星型和族树型网络适合点多多点、距离相对较近的应用。</p></li><li><p>代码设置，在“nwk_global.h”文件中进行设置,159行处</p><blockquote><p><img src="../../../../../%E5%9B%BE%E7%89%87/%E8%B5%84%E6%96%99/01Typora%E4%BF%9D%E5%AD%98/image-20210531093825604.png" alt="image-20210531093825604"></p></blockquote></li></ul></li></ol><h2 id="0x02-单播通信"><a href="#0x02-单播通信" class="headerlink" title="0x02 单播通信"></a>0x02 单播通信</h2><h3 id="1-单播通信理论"><a href="#1-单播通信理论" class="headerlink" title="1.单播通信理论"></a>1.单播通信理论</h3><ul><li><p>Zigbee网络通信方式有4种：单播，广播，组播，绑定(MAC)。</p></li><li><p>单播通信的特点:在Zigbee网络里，模块之间要进行通信，发射模块要明确知道接收模块的网络地址。</p></li><li><p>Zigbee模块的地址特点:模块在加入网络的时候，父节点随机分配网络地址给子节点。但是协调器模块在网络里的地址永远都是0x00。</p></li><li><p>单播发送数据需要明确的信息</p><ul><li>(1)目标地址</li><li>(2)目标端点与簇</li><li>(3)要发送的数据大小</li></ul></li></ul><h3 id="2-GenericApp-SendTheMessage"><a href="#2-GenericApp-SendTheMessage" class="headerlink" title="2.GenericApp_SendTheMessage()"></a>2.GenericApp_SendTheMessage()</h3><ul><li>该函数在GenericApp.c里的GenericApp_SendTheMessage函数里:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AF_DataRequest(</span><br><span class="line">              &amp;GenericApp_DstAddr, <span class="comment">//目标的网络地址指针</span></span><br><span class="line">              &amp;GenericApp_epDesc,<span class="comment">//端点描述符指针</span></span><br><span class="line">              GENERICAPP_CLUSTERID,<span class="comment">//目标簇</span></span><br><span class="line">              (byte)osal_strlen( theMessageData ) + <span class="number">1</span>,<span class="comment">//发送数据的大小</span></span><br><span class="line">              (byte *)&amp;theMessageData,<span class="comment">//发送数据缓冲区的地址</span></span><br><span class="line">              &amp;GenericApp_TransID,<span class="comment">//这是个全局变量，用来保存发送的次数</span></span><br><span class="line">              AF_DISCV_ROUTE, AF_DEFAULT_RADIUS );<span class="comment">//发送路径，don&#x27;t care</span></span><br></pre></td></tr></table></figure><h3 id="3-网络地址结构体"><a href="#3-网络地址结构体" class="headerlink" title="3.网络地址结构体"></a>3.网络地址结构体</h3><ul><li>网络地址结构体就是定义在GenericApp.c前面的一个结构体变量，该类型为afAddrType_t，系统已经默认定义了一个网络地址结构体变量GenericApp_DstAddr，我们可以在GenericApp_Init()函数中，对网络地址结构体变量的成员进行赋值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网络地址结构体:</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">            uint16      shortAddr;<span class="comment">//网络地址</span></span><br><span class="line">            ZLongAddr_t extAddr; <span class="comment">//MAC地址</span></span><br><span class="line">     &#125; addr;</span><br><span class="line">     afAddrMode_t addrMode;<span class="comment">//通信模式</span></span><br><span class="line">     byte endPoint; <span class="comment">//指定的端点</span></span><br><span class="line">     uint16 panId;  <span class="comment">//don&#x27;t care</span></span><br><span class="line">&#125; afAddrType_t;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通信模式枚举类型:</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        afAddrNotPresent = AddrNotPresent,<span class="comment">//当前不确定</span></span><br><span class="line">        afAddr16Bit      = Addr16Bit,<span class="comment">//单播通信模式</span></span><br><span class="line">        afAddr64Bit      = Addr64Bit,<span class="comment">//MAC通信模式</span></span><br><span class="line">        afAddrGroup      = AddrGroup,<span class="comment">//组播通信模式</span></span><br><span class="line">        afAddrBroadcast  = AddrBroadcast<span class="comment">//广播通信模式</span></span><br><span class="line">&#125; afAddrMode_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-端点"><a href="#4-端点" class="headerlink" title="4.端点"></a>4.端点</h3><ul><li><p>(1)通常发送的数据要明确该数据是给接收模块的哪个任务层用的，而这个就是用端点来指定的</p></li><li><p>(2)端点是一个字节的编号，通常为定义在GenericApp.h中的一个宏。端点必须要与任务层绑定，而这个就是用端点描述符来实现的。</p></li><li><p>(3)端点描述符是一个结构体变量，该变量定义在GenericApp.c开头，我们也可以定义新的端点描述符。该结构体的类型为 endPointDesc_t，系统也默认定义了一个端点描述符GenericApp_epDesc。</p></li><li><p>(4)我们可以在 GenericApp_Init()函数中，把新的端点描述符变量赋值，使新的端点与某个任务层绑定。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 端点结构体类型:</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       byte endPoint;<span class="comment">//端点的值</span></span><br><span class="line">       byte *task_id;  <span class="comment">//与端点绑定的任务层ID</span></span><br><span class="line">       SimpleDescriptionFormat_t *simpleDesc;<span class="comment">//端点的描述信息,don’t care</span></span><br><span class="line">       afNetworkLatencyReq_t latencyReq;<span class="comment">//don’t care</span></span><br><span class="line">&#125; endPointDesc_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-簇"><a href="#5-簇" class="headerlink" title="5.簇"></a>5.簇</h3><ul><li><p>(1)在接收模块中，每个任务层可以对不同种类的数据采取不同的处理方式，这里的数据种类就是簇(CLUSTER)</p></li><li><p>(2)在发送模块中，簇是定义在GenericApp.h中的一个宏，我们也可以定义新的簇。</p></li><li><p>(3) 系统也默认定义了一个簇 GenericApp_CLUSTERID，在GenericApp.h中</p></li></ul><h3 id="6-应用任务层数据接收函数"><a href="#6-应用任务层数据接收函数" class="headerlink" title="6.应用任务层数据接收函数"></a>6.应用任务层数据接收函数</h3><ul><li><p>(1)该函数为GenericApp.c中的 void GenericApp_MessageMSGCB( afIncomingMSGPacket_t *pkt )</p></li><li><p>(2)在switch语句中可以定义对不同的簇采用不同的方式处理数据</p></li><li><p>(3)该函数中的pkt-&gt;cmd.Data就是接收数据的首地址</p></li></ul><h2 id="0x03-无线通信代码编写过程"><a href="#0x03-无线通信代码编写过程" class="headerlink" title="0x03 无线通信代码编写过程"></a>0x03 无线通信代码编写过程</h2><h3 id="1-设置信道与PANID"><a href="#1-设置信道与PANID" class="headerlink" title="1.设置信道与PANID"></a>1.设置信道与PANID</h3><blockquote><p>在Tools文件组里的f8wConfig.cfg文件中</p><p>-DDEFAULT_CHANLIST=0x00000800 // 11 - 0x0B</p><p>-DZDAPP_CONFIG_PAN_ID=0x1234</p></blockquote><h3 id="2-设置AF-DataRequest结构体"><a href="#2-设置AF-DataRequest结构体" class="headerlink" title="2.设置AF_DataRequest结构体"></a>2.设置AF_DataRequest结构体</h3><p>在GenericApp.c里的GenericApp_SendTheMessage函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AF_DataRequest(</span><br><span class="line">    &amp;GenericApp_DstAddr, <span class="comment">//目标的网络地址指针</span></span><br><span class="line">    &amp;GenericApp_epDesc,<span class="comment">//端点描述符指针</span></span><br><span class="line">    GENERICAPP_CLUSTERID,<span class="comment">//目标簇</span></span><br><span class="line">    (byte)osal_strlen( theMessageData ) + <span class="number">1</span>,<span class="comment">//发送数据的大小</span></span><br><span class="line">    (byte *)&amp;theMessageData,<span class="comment">//发送数据缓冲区的地址</span></span><br><span class="line">    &amp;GenericApp_TransID,<span class="comment">//这是个全局变量，用来保存发送的次数</span></span><br><span class="line">    AF_DISCV_ROUTE, AF_DEFAULT_RADIUS );<span class="comment">//发送路径，don&#x27;t care</span></span><br></pre></td></tr></table></figure><p><img src="../../../../../%E5%9B%BE%E7%89%87/%E8%B5%84%E6%96%99/01Typora%E4%BF%9D%E5%AD%98/image-20210528162437459.png" alt="image-20210528162437459"></p><p><img src="../../../../../%E5%9B%BE%E7%89%87/%E8%B5%84%E6%96%99/01Typora%E4%BF%9D%E5%AD%98/image-20210528164343762.png" alt="image-20210528164343762"></p><p><img src="../../../../../%E5%9B%BE%E7%89%87/%E8%B5%84%E6%96%99/01Typora%E4%BF%9D%E5%AD%98/image-20210528164903849.png" alt="image-20210528164903849"></p>]]></content>
      
      
      <categories>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实训 </tag>
            
            <tag> Zigbee通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实训Day04</title>
      <link href="2021/05/27/12%E5%AE%9E%E8%AE%ADDay04/"/>
      <url>2021/05/27/12%E5%AE%9E%E8%AE%ADDay04/</url>
      
        <content type="html"><![CDATA[<h1 id="UART通信"><a href="#UART通信" class="headerlink" title="UART通信"></a>UART通信</h1><h2 id="0x01-什么是UART？"><a href="#0x01-什么是UART？" class="headerlink" title="0x01 什么是UART？"></a>0x01 什么是UART？</h2><ul><li><p>通用异步收发传输器(Universal Asynchronous Receiver/Transmitter)，通常称作UART，是一种<strong>异步</strong>收发传输器</p><blockquote><ul><li><p>同步通信：发送方发出数据后，等接收方发回响应以后才发下一个数据包</p></li><li><p>异步通信：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式</p></li><li><p>总结</p><ul><li>同步通信是阻塞方式，异步通信是非阻塞方式</li><li>常见通信总线协议中，I2C、CPI属于同步通信，UART属于异步通信</li></ul></li><li><p>注意</p><ul><li><p>同步通信的通信双方必须先建立同步，双方的时钟需要调整到同一个频率</p></li><li><p>异步通信两个通信设备没有时钟信号，因此需要约定好波特率，常见的有4800，9600,115200等，土工室数据起始位和停止位必不可少</p></li></ul></li></ul></blockquote></li><li><p>一种常用也是最简单的串行数据传输协议。数据线只需要两根就可以实现全双工</p><ul><li><p>Tx:发送数据线</p></li><li><p>Rx:接收数据线</p><blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210528101648592.png" alt="image-20210528101648592"></p><p>RS-232标准:上位机和下位机串口通信时的接线方式,主要是接线需要接对</p></blockquote></li></ul></li></ul><h2 id="0x02-上位机和下位机"><a href="#0x02-上位机和下位机" class="headerlink" title="0x02 上位机和下位机"></a>0x02 上位机和下位机</h2><blockquote><p>通信，通信，两台设备才能进行通信</p></blockquote><ul><li>模块之间的通信,根据其在系统中的功能与作用可分为上位机 与 下位机</li><li>上位机：处理性能强的计算机，数据的统一处理都在上位机完场</li><li>下位机：数据采集和发送的终端，处理性能单一的计算机</li><li>注意：一般一个上位机会对应多个下位机，这种模式可以使数据处理的更加全面，同时也大大降低成本。</li></ul><h2 id="0x03-UART数据帧"><a href="#0x03-UART数据帧" class="headerlink" title="0x03 UART数据帧"></a>0x03 UART数据帧</h2><ul><li><p>在协议层(UART protocol 串口协议)，规定了数据包的内容，串口发送和接收的数据包都是以帧为单位，Frame</p></li><li><p>数据包(帧Frame)内容组成：起始位(1bit)+数据位(5~9bit)+校验位(0/1bit)+停止位(0.5,1,1.5bit)</p><ul><li><p>起始位：一个周期的低电平</p></li><li><p>数据位：5~9bits数据位，具体多少需要双方协商，并优先传送最低位(LSB)</p></li><li><p>校验位</p><ul><li><p>0校验：校验位总为“0”</p></li><li><p>1校验：校验位总为“1”</p></li><li><p>奇校验：有效数据和校验位中“1”的个数为奇数</p><blockquote><p>譬如0101,2个1，为达到奇校验，校验位为“1”</p></blockquote></li><li><p>偶校验：有效数据和校验位中“1”的个数为偶数</p><blockquote><p>譬如0100,1个1，为达到偶校验，校验位为“1”</p></blockquote></li></ul></li><li><p>停止位：高电平，1个停止位</p></li></ul></li><li><p>波特率(Baudrate):传输速率，即每一秒传输多少个bit为</p><ul><li>4800</li><li>9600</li><li>115200</li></ul></li></ul><h2 id="0x04-串口配置"><a href="#0x04-串口配置" class="headerlink" title="0x04 串口配置"></a>0x04 串口配置</h2><h3 id="1-结构体halUARTCfg-t"><a href="#1-结构体halUARTCfg-t" class="headerlink" title="1.结构体halUARTCfg_t"></a>1.结构体halUARTCfg_t</h3><ul><li>halUARTCfg_t结构体是串口初始化的结构体，可以对串口的初始化进行相应设置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span>                configured;<span class="comment">//是否设置串口</span></span><br><span class="line">    uint8               baudRate; <span class="comment">//波特率设置</span></span><br><span class="line">    <span class="keyword">bool</span>                flowControl;<span class="comment">//控制流设置</span></span><br><span class="line">    uint16              flowControlThreshold;<span class="comment">//RX缓存安全字节数(了解)</span></span><br><span class="line">    uint8               idleTimeout;<span class="comment">//RX来数据超时时间(了解)</span></span><br><span class="line">    halUARTBufControl_t rx;<span class="comment">//接收数据长度</span></span><br><span class="line">    halUARTBufControl_t tx;<span class="comment">//发送数据长度</span></span><br><span class="line">    <span class="keyword">bool</span>                intEnable;<span class="comment">//中断使能</span></span><br><span class="line">    uint32              rxChRvdTime;<span class="comment">//接收数据时间</span></span><br><span class="line">    halUARTCBack_t      callBackFunc;<span class="comment">//回调函数</span></span><br><span class="line">&#125;halUARTCfg_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-串口初始化实例"><a href="#2-串口初始化实例" class="headerlink" title="2.串口初始化实例"></a>2.串口初始化实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitUart</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">halUARTCfg_t   uartConfig;       <span class="comment">// 声明一个halUARTCfg_t结构体</span></span><br><span class="line">uartConfig.configured           = TRUE;  </span><br><span class="line">uartConfig.baudRate             = HAL_UART_BR_9600;  <span class="comment">// 波特率直接修改数字</span></span><br><span class="line">uartConfig.flowControl          = FALSE;</span><br><span class="line">uartConfig.flowControlThreshold = <span class="number">64</span>; </span><br><span class="line">uartConfig.rx.maxBufSize        = <span class="number">128</span>;  </span><br><span class="line">uartConfig.tx.maxBufSize        = <span class="number">128</span>;  </span><br><span class="line">uartConfig.idleTimeout          = <span class="number">6</span>;    </span><br><span class="line">uartConfig.intEnable            = TRUE;                </span><br><span class="line">uartConfig.callBackFunc         = SerialApp_CallBack;   </span><br><span class="line">HalUARTOpen (HAL_UART_PORT_0, &amp;uartConfig);  <span class="comment">// 初始化，将前面配置的uartConfig作为参数传递进去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后的<strong>HalUARTOpen</strong>函数，将串口初始化结构体作为参数对串口0进行初始化</li></ul><h3 id="3-串口读操作函数"><a href="#3-串口读操作函数" class="headerlink" title="3.串口读操作函数"></a>3.串口读操作函数</h3><ul><li><p>串口的读操作函数为HalUARTRead()，主要功能是读取上位机通过串口发送至设备节点的数据。</p></li><li><p>uint16 HalUARTRead(uint8 port, uint8 *buf, uint16 len)</p><ul><li><p>@port：串口端口的设置，可以设置为串口0或串口1；</p></li><li><p>@buf：数据缓冲区；</p></li></ul><ul><li><p> @len：数据长度。</p></li><li><p> 返回值:实际成功读取的字节数</p></li></ul></li></ul><h3 id="4-串口写操作函数"><a href="#4-串口写操作函数" class="headerlink" title="4.串口写操作函数"></a>4.串口写操作函数</h3><ul><li><p>串口的写操作函数为HalUARTWrite()，主要功能是实现向上位机或其他设备通过串口发送数据。</p><ul><li><p>uint16 HalUARTWrite(uint8 port, uint8 *buf, uint16 len)</p></li><li><p> @port：串口端口的设置，可以设置为串口0或串口1；</p></li><li><p> @buf：数据缓冲区；</p></li><li><p> @len：数据长度。</p></li><li><p> 返回值:实际成功发送的字节数</p></li></ul></li></ul><h2 id="0x05-DHT11温湿度传感器"><a href="#0x05-DHT11温湿度传感器" class="headerlink" title="0x05 DHT11温湿度传感器"></a>0x05 DHT11温湿度传感器</h2><blockquote><p>只简单介绍使用过的部分，因为只是进行了简单的使用，并没有深入了解</p></blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210528110346937.png" alt="image-20210528110346937"></p><h3 id="1-DHT11数据传输协议"><a href="#1-DHT11数据传输协议" class="headerlink" title="1.DHT11数据传输协议"></a>1.DHT11数据传输协议</h3><ul><li><p>DHT11通过DATA线与MCU实现半双工通讯。每次通讯时间4ms左右(听不懂)</p></li><li><p>数据：小数部分和整数部分</p></li><li><p>数据传输：一次完整的数据传输为40bit,高位先出</p></li><li><p>数据格式</p><p> 40bits = 8bit湿度整数数据+8bit湿度小数数据</p><pre><code>    +8bit温度整数数据+8bit温度小数数据    +8bit**校验和** </code></pre></li><li><p>校验</p><ul><li>数据传送正确时，校验和数据 = 8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据所得结果的末8位。</li><li>即校验和数据 =（ 8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据）% 256(2的8次方)</li></ul></li></ul><h3 id="2-使用DHT11温湿度显示数据"><a href="#2-使用DHT11温湿度显示数据" class="headerlink" title="2.使用DHT11温湿度显示数据"></a>2.使用DHT11温湿度显示数据</h3><h4 id="1-P0-4引脚初始化"><a href="#1-P0-4引脚初始化" class="headerlink" title="1).P0_4引脚初始化"></a>1).P0_4引脚初始化</h4><ul><li>DHT11使用的是CC2530的P0_4引脚，初始化引脚的输入和输出模式</li><li>在dht11.c中进行初始化，具体CPIO初始化可参考Day02记录</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DATA_IO_input_Cfg</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//设置为上拉输入模式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P0SEL &amp;= <span class="number">0xEF</span>; <span class="comment">// 0001 0000把P0_4设置为普通模式</span></span><br><span class="line">    P0DIR &amp;= <span class="number">0xEF</span>; <span class="comment">// 1110 1111把P0_4置为输入模式</span></span><br><span class="line">    P1INP &amp;= <span class="number">0xEF</span>; <span class="comment">// 1110 1111 把P1_2设置为上下拉模式</span></span><br><span class="line">    P2INP &amp;= <span class="number">0xDF</span>; <span class="comment">// 1101 1111 把P1设置为上拉模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DATA_IO_output_Cfg</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//设置为输出模式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P0SEL &amp;= <span class="number">0xEF</span>; <span class="comment">// 0001 0000把P0_4设置为普通模式</span></span><br><span class="line">    P0DIR |= <span class="number">0x10</span>; <span class="comment">// 0001 0000把P0_4置为输入模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>因为数据采集和处理函数已经给我们准备好了，因此我们只要在Z-stack协议栈中创建事件进行调用即可</p><blockquote><p>数据采集和处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Start_DHT11</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//开始采集数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">5</span>];</span><br><span class="line">  DATA_IO_output_Cfg();<span class="comment">//设置为输出模式</span></span><br><span class="line">  DATA = <span class="number">0</span>;<span class="comment">//发送开始信号</span></span><br><span class="line">  MicroWait(<span class="number">20000</span>);<span class="comment">//延时至少18ms</span></span><br><span class="line">  DATA = <span class="number">1</span>;<span class="comment">//拉高20~40us</span></span><br><span class="line">  MicroWait(<span class="number">40</span>);</span><br><span class="line">  </span><br><span class="line">  DATA_IO_input_Cfg();<span class="comment">//设置为输入模式</span></span><br><span class="line">  <span class="keyword">while</span>(!(DATA ==<span class="number">0</span>));<span class="comment">//等DHT11回响应信号</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(!(DATA ==<span class="number">1</span>));<span class="comment">//等DHT11把总线拉高，准备接收数据</span></span><br><span class="line">  buf[<span class="number">0</span>] = Read_Byte();</span><br><span class="line">  buf[<span class="number">1</span>] = Read_Byte();</span><br><span class="line">  buf[<span class="number">2</span>] = Read_Byte();</span><br><span class="line">  buf[<span class="number">3</span>] = Read_Byte();</span><br><span class="line">  buf[<span class="number">4</span>] = Read_Byte();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((buf[<span class="number">0</span>]+buf[<span class="number">1</span>]+buf[<span class="number">2</span>]+buf[<span class="number">3</span>])%<span class="number">256</span> == buf[<span class="number">4</span>])</span><br><span class="line">  &#123;</span><br><span class="line">    humidity = buf[<span class="number">0</span>];</span><br><span class="line">    temperature = buf[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>步骤：为事件定义编码-宏–&gt;添加提取事件类处理代码–调用事件设置函数</p></blockquote><h4 id="2-为事件定义编码-宏"><a href="#2-为事件定义编码-宏" class="headerlink" title="2).为事件定义编码-宏"></a>2).为事件定义编码-宏</h4><p>在GenericApp.h中添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERICAPP_MY_EVT1       0x0004</span></span><br></pre></td></tr></table></figure><h4 id="3-添加提取事件类处理代码"><a href="#3-添加提取事件类处理代码" class="headerlink" title="3).添加提取事件类处理代码"></a>3).添加提取事件类处理代码</h4><p>GenericApp.c中的GenericApp_ProcessEvent()函数中最后部分添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( events &amp; GENERICAPP_MY_EVT1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> temp[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">if</span>(Start_DHT11() == <span class="number">1</span>) <span class="comment">// 此处调用了dht11.c中的温湿度采集和处理程序</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(temp,<span class="string">&quot;temperature:%d,humidity:%d\r\n&quot;</span>,temperature,humidity);</span><br><span class="line">      HalUARTWrite(HAL_UART_PORT_0,temp,<span class="built_in">strlen</span>((<span class="keyword">char</span> *)temp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        HalUARTWrite(HAL_UART_PORT_0,<span class="string">&quot;error\r\n&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;error\r\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (events ^ GENERICAPP_MY_EVT1); <span class="comment">// 清零</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="4-添加调用事件设置函数代码"><a href="#4-添加调用事件设置函数代码" class="headerlink" title="4).添加调用事件设置函数代码"></a>4).添加调用事件设置函数代码</h4><p>GenericApp.c中的GenericApp_ProcessEvent()函数中switch中添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GenericApp_NwkState == DEV_ZB_COORD) <span class="comment">// 网络状态变成协调器</span></span><br><span class="line">&#123;</span><br><span class="line">    osal_set_event(GenericApp_TaskID,GENERICAPP_MY_EVT1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://zhuanlan.zhihu.com/p/136806005">串口通信（UART）介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实训 </tag>
            
            <tag> UART </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实训Day03</title>
      <link href="2021/05/26/11%E5%AE%9E%E8%AE%ADDay03/"/>
      <url>2021/05/26/11%E5%AE%9E%E8%AE%ADDay03/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Z-stack协议栈"><a href="#0x01-Z-stack协议栈" class="headerlink" title="0x01 Z-stack协议栈"></a>0x01 Z-stack协议栈</h2><h3 id="1-Z-stack协议栈是什么？"><a href="#1-Z-stack协议栈是什么？" class="headerlink" title="1.Z-stack协议栈是什么？"></a>1.Z-stack协议栈是什么？</h3><ul><li><p>非人话：T1公司推出的ZigBee规范的商用协议</p></li><li><p>人话：为了使Zigbee的开发更加简单高效，实现各个功能的实例框架代码</p><blockquote><p>我的理解就是一个框架，我们想要实现自己的功能程序，只需要在协议栈的基础上修改或添加即可</p></blockquote></li><li><p>由物理层、MAC层、网络层和应用层组成，由于Z-Stack协议栈是一个<strong>半开源</strong>的协议栈，MAC层和网络层的部分源代码是非开源的，因此我们学习的开源部分，主要包括<strong>main函数、APP层、ZDO层、NWK层和HAL层</strong>。</p></li></ul><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210527234143880.png" alt="image-20210527234143880"></p><blockquote><p>因为是框架，并不需要都使用到，只简单记录使用到的部分</p></blockquote><h3 id="2-协议栈具体内容"><a href="#2-协议栈具体内容" class="headerlink" title="2.协议栈具体内容"></a>2.协议栈具体内容</h3><h4 id="1）main函数"><a href="#1）main函数" class="headerlink" title="1）main函数"></a>1）main函数</h4><ul><li><p>main函数具体做量两件事：系统初始化和调用函数Osal_start_system()来启动协议栈</p></li><li><p>协议栈的运行机制：Zmain.c中的main函数是整个协议栈的入口，其中包含了各种硬件的初始化和协议栈的初始化</p></li><li><p>直到调用osal_start_system()函数，协议栈开始真正运行</p></li></ul><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210527234849563.png" alt="image-20210527234849563"></p><blockquote><p>这些函数就是各种硬件的初始化和协议栈的初始化</p></blockquote><h4 id="2）osal-start-system-函数"><a href="#2）osal-start-system-函数" class="headerlink" title="2）osal_start_system()函数"></a>2）osal_start_system()函数</h4><ul><li>调用后不再返回，意思就是运行这个函数后，这个函数后面的语句不会再执行</li><li>函数里面存着for死循环，这也是为什么我们自定义的初始化函数需要放在osal_start_system之前，放在后面是不会被执行的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">led_init();</span><br><span class="line">exit_init();</span><br><span class="line"><span class="comment">// 执行完上面的函数之后开始调用osal_start_system函数，协议栈正式运行</span></span><br><span class="line">osal_start_system(); <span class="comment">// No Return from here</span></span><br></pre></td></tr></table></figure><h4 id="3）APP层分析"><a href="#3）APP层分析" class="headerlink" title="3）APP层分析"></a>3）APP层分析</h4><ul><li><p>Z-Stack协议栈的APP层主要功能是实现用户定义的事件，</p></li><li><p>如果要编写应用程序，涉及三个文件，用户只需要添加这几个文件，编写自己的任务处理函数就可以了</p><ul><li><p>主文件–GenericApp.c：存放具体的任务事件处理函数，有两个功能</p><ul><li>对应用层用户定义的任务进行初始化</li><li>调用事件处理函数GenericApp_ProcessEvent()</li></ul></li><li><p>主文件的头文件—SampleApp.h</p></li><li><p>操作系统接口文件—OSAL_SampleApp.c：专门存放任务处理函数数组tasksArr[]的文件，实现Z-stack代码的公用</p><blockquote><p>目前为止整个实训只需要对GenericApp.c文件操</p></blockquote></li></ul></li></ul><h4 id="4）任务和事件"><a href="#4）任务和事件" class="headerlink" title="4）任务和事件"></a>4）任务和事件</h4><ul><li><p>在ZSTACK里按照代码功能来划分，分成不同的层:硬件层、网络层、应用层。每一个层都是一个任务</p></li><li><p>每个任务分配一个一个字节的唯一编号。然后每个任务要做很多事情，这个称为事件</p></li><li><p>Zigbee事件分为两类，系统定义事件和用户定义事件</p><ul><li>系统类事件是协议栈已定义好的</li><li>用户类事件是我们用户层面(APP层)来定义的</li></ul></li><li><p><strong>重点</strong>:事件类号采用一个16bit的常量,只有一个bit为1,其他全为0</p><blockquote><p>事件类号编码使用独热码编码，独热码是只有一个bit为1，其他全为0的一种码制，</p></blockquote><ul><li>提取系统类事件：events &amp; SYS_EVENT_MSG</li><li>清除系统类事件：events ^ SYS_EVENT_MSG</li><li>由于事件类号是16bit，因此zigbee事件类只有16个，系统类事件SYS_EVENT_MSG使用0x8000，所以自行一事件类只有15个</li></ul></li></ul><h4 id="5）Generic-ProcessEvent-函数"><a href="#5）Generic-ProcessEvent-函数" class="headerlink" title="5）Generic_ProcessEvent()函数"></a>5）Generic_ProcessEvent()函数</h4><ul><li><p>原型：UINT16  Generic_ProcessEvent( byte task_id, UINT16 events )</p></li><li><p><strong>事件处理函数</strong>，它会把events包含的事件进行处理</p></li><li><p>两个参数：task_id任务号和events事件类号</p><blockquote><p>事件处理函数首先根据事件类号来判断是何种类型事件，然后根据任务号得到消息指针pMsg，最后根据消息指针结构里的事件号pMsg-&gt;event来具体处理事件，event为8bit的常量，系统event在ZComDef.h里定义</p></blockquote></li></ul><h4 id="6）osal-set-event-函数"><a href="#6）osal-set-event-函数" class="headerlink" title="6）osal_set_event()函数"></a>6）osal_set_event()函数</h4><ul><li><p>设置任务事件函数</p></li><li><p>uint8 osal_set_event(uint8 task_id,uint16 event_flag)</p><ul><li>@task_id:任务编号,应用层为GenericApp_TaskID</li><li>@event_flag:事件编号，就是在GenericApp.h中定义的宏</li></ul></li></ul><h4 id="7）osal-start-timerEx-函数"><a href="#7）osal-start-timerEx-函数" class="headerlink" title="7）osal_start_timerEx(函数)"></a>7）osal_start_timerEx(函数)</h4><ul><li><p>延时设置任务事件函数</p></li><li><p>uint8 osal_start_timerEx( uint taskID,uint16 event_flag,uint16 timeout_value);</p><ul><li>@task_id:任务编号,应用层为GenericApp_TaskID</li><li>@event_flag:事件编号，就是在GenericApp.h中定义的宏</li><li>@timeout_value:延时时间，单位为ms</li></ul></li></ul><blockquote><p>注意:该函数调用后会立马返回，这个延时功能是用定时器实现的。该函数调用多次不会多次添加事件，只是重新设置延时时间而已。</p></blockquote><h2 id="0x02-协议栈工程"><a href="#0x02-协议栈工程" class="headerlink" title="0x02 协议栈工程"></a>0x02 协议栈工程</h2><h4 id="1-协议栈模块添加"><a href="#1-协议栈模块添加" class="headerlink" title="1.协议栈模块添加"></a>1.协议栈模块添加</h4><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210528001010246.png" alt="image-20210528001010246"></p><ul><li><p>使用时候只需要按照第二行展示的路径打开工作空间便可以了，打开的工作空间便是协议栈的框架，我们只需要在此基础上进行修改即可</p></li><li><p>Z-Stack协议软件包中提供了3个典型的用户示例工程，如下图，后续使用的是通用用户示例工程</p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210528001421360.png" alt="image-20210528001421360"></p></li><li><p>当我们切换选项卡时所有的配置需要重新进行设置</p></li></ul><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210528001610273.png" alt="image-20210528001610273"></p><h4 id="2-功能模块的添加"><a href="#2-功能模块的添加" class="headerlink" title="2.功能模块的添加"></a>2.功能模块的添加</h4><h5 id="1）-添加led-c-和led-h"><a href="#1）-添加led-c-和led-h" class="headerlink" title="1）.添加led.c 和led.h"></a>1）.添加led.c 和led.h</h5><ul><li>1）把led.c 和led.h 复制到Source目录中</li><li>2）在App文件组中单击右键添加.c文件，.h文件</li></ul><h5 id="2）-添加头文件"><a href="#2）-添加头文件" class="headerlink" title="2）.添加头文件"></a>2）.添加头文件</h5><ul><li><p>在Zmain.c和GenericApp.c中添加包含头文件命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led_key.h&quot;</span></span></span><br></pre></td></tr></table></figure></li></ul><h5 id="3）-添加函数"><a href="#3）-添加函数" class="headerlink" title="3）.添加函数"></a>3）.添加函数</h5><ul><li><p>LED初始化函数放到main函数末尾osal_start_system()的前面</p><blockquote><p>其他的初始化或功能函数也是如此，只能放前面，不能放后面，原因前面有介绍</p></blockquote></li></ul><h5 id="4）-其他操作"><a href="#4）-其他操作" class="headerlink" title="4）.其他操作"></a>4）.其他操作</h5><ul><li><p>编译若发现错误可能是由于IAR编译器语法要求比较严格，需要Options–&gt;C/C++ Compiler把 Require prototype勾去掉</p><blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210528002318607.png" alt="image-20210528002318607"></p></blockquote></li><li><p>在GenericApp.c文件中的<strong>GenericApp_ProcessEvent</strong>函数中的switch语句的最后一个case进行修改,用if else使模式在不同的工作状态下，亮不同的灯。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ZDO_STATE_CHANGE:</span><br><span class="line">    GenericApp_NwkState = (devStates_t)(MSGpkt-&gt;hdr.status);</span><br><span class="line">    <span class="keyword">if</span> (GenericApp_NwkState == DEV_ZB_COORD) <span class="comment">// 网络状态变成协调器</span></span><br><span class="line">    &#123;</span><br><span class="line">        led_ctrl(LED0,LED_ON);</span><br><span class="line">        led_ctrl(LED1,LED_ON);</span><br><span class="line">        osal_set_event(GenericApp_TaskID,GENERICAPP_MY_EVT1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(GenericApp_NwkState == DEV_ROUTER)  <span class="comment">// 网络状态变成路由器</span></span><br><span class="line">    &#123;</span><br><span class="line">        led_ctrl(LED0,LED_ON);</span><br><span class="line">        led_ctrl(LED1,LED_OFF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(GenericApp_NwkState == DEV_END_DEVICE)  <span class="comment">// 网络状态变成网络终端</span></span><br><span class="line">    &#123;</span><br><span class="line">        led_ctrl(LED0,LED_OFF);</span><br><span class="line">        led_ctrl(LED1,LED_ON);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li><li><p>去掉f8w2530.xcl文件中Include these two lines when generating a .hex file for banked code model: 后面两行</p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210528002644649.png" alt="image-20210528002644649"></p></li></ul><h4 id="3-事件的定义和添加"><a href="#3-事件的定义和添加" class="headerlink" title="3.事件的定义和添加"></a>3.事件的定义和添加</h4><h5 id="1）-定义事件宏"><a href="#1）-定义事件宏" class="headerlink" title="1）.定义事件宏"></a>1）.定义事件宏</h5><ul><li><p>在GenericApp.h中定义事件的宏，也就是定义事件的16位bit编码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GenericApp_MY_EVT           0X0004</span></span><br><span class="line"><span class="comment">// 只能有一位是1，其余的都是0</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="2）定义事件要做的事情"><a href="#2）定义事件要做的事情" class="headerlink" title="2）定义事件要做的事情"></a>2）定义事件要做的事情</h5><ul><li><p>在GenericApp.c文件中的GenericApp_ProcessEvent()函数定义事件要做的事情</p><blockquote><p>在事件处理函数中添加事件处理代码</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( events &amp; GENERICAPP_MY_EVT2 )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">// 事件要做的事</span></span><br><span class="line">   P1_0 = !P1_0;</span><br><span class="line">   P1_1 = !P1_1;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> str[<span class="number">32</span>] = &#123;<span class="string">&quot;hello,are you OK?\r\n&quot;</span>&#125;;</span><br><span class="line">   HalUARTWrite(HAL_UART_PORT_0,str,<span class="built_in">strlen</span>((<span class="keyword">char</span> *)str)); </span><br><span class="line">   <span class="comment">// osal_start_timerEx(GenericApp_TaskID,GENERICAPP_MY_EVT1,1000);</span></span><br><span class="line">   <span class="comment">// return unprocessed events</span></span><br><span class="line">   <span class="keyword">return</span> (events ^ GENERICAPP_MY_EVT2); <span class="comment">// 清零</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GenericApp_NwkState == DEV_ZB_COORD) <span class="comment">// 网络状态变成协调器</span></span><br><span class="line">&#123;</span><br><span class="line">    osal_set_event(GenericApp_TaskID,GENERICAPP_MY_EVT1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="http://www.cxyzjd.com/article/weixin_44127810/104341027">ZigBee学习笔记八-浅析协议栈</a></p><p><a href="https://blog.csdn.net/DIANZI520SUA/article/details/105687911">ZigBee 事件相关</a></p>]]></content>
      
      
      <categories>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实训 </tag>
            
            <tag> Z-stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实训Day02</title>
      <link href="2021/05/25/10%E5%AE%9E%E8%AE%ADDay02/"/>
      <url>2021/05/25/10%E5%AE%9E%E8%AE%ADDay02/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-CC2530芯片"><a href="#0x01-CC2530芯片" class="headerlink" title="0x01 CC2530芯片"></a>0x01 CC2530芯片</h2><ul><li>版本：CC2530-F32/64/128/256KB分别对应32/64/128/256KB闪存</li><li>内置射频收发器，具有无线能力</li></ul><h3 id="引脚"><a href="#引脚" class="headerlink" title="引脚"></a>引脚</h3><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210526111610858.png" alt="image-20210526111610858"></p><ul><li>一共40个引脚,加上背面焊盘必须接地所以可以看作41个脚</li><li>一共21个通用引脚 P0_0-P0_7,P1_0-P1_7,P2_0-P2_5，可理解成GPIO口</li><li>程序下载仿真接口需5个引脚。VCC,GND,RESET,<strong>P2_1,P2_2</strong></li><li>P1_0,P1_1这两个引脚IO的驱动电流能够达到20mA,其余引脚只能达到4mA</li><li>30号引脚接偏置电阻，40号引脚接去耦电容，20号引脚接复位电路，25,26引脚接无线收发</li></ul><h2 id="0x02-什么是GPIO"><a href="#0x02-什么是GPIO" class="headerlink" title="0x02 什么是GPIO"></a>0x02 什么是GPIO</h2><ul><li><p>英文：General Purpose Input Output</p></li><li><p>通用输入输出，有时简称”IO口”，既能当输入口使用，又能当输出口使用</p></li><li><p>可以作为普通IO口，用来输出高电平或低电平，或者获取输入状态。同时也可以复用为片上外设功能，如UART，ADC采集通道 ,PWM输出通道，等等</p></li><li><p>总结：GPIO就是芯片上一根干啥都行的引脚</p></li><li><p>cc2530总共有21个GPIO口，这些IO口分为3组，分别为                </p><p>​      P0_0<del>P0_7    P1_0</del>P1_7         P2_0~P2_4    </p></li></ul><h2 id="0x03-GPIO输入模式"><a href="#0x03-GPIO输入模式" class="headerlink" title="0x03 GPIO输入模式"></a>0x03 GPIO输入模式</h2><ul><li><p>上拉模式</p><ul><li>默认输入时高电平，可以被外部拉低</li></ul><blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210525144417010.png" alt="image-20210525144417010"></p></blockquote></li><li><p>下拉模式</p><ul><li>默认低电平，可以外部变高</li></ul><blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210525144606205.png" alt="image-20210525144606205"></p></blockquote></li><li><p>三态模式</p><ul><li>逻辑器件：三态门</li><li>除了0和1两种状态外，还有一个高阻态(电阻很大，相当于开路)</li><li>高阻态：相当于该器件所在电路处于断开状态，因为不可能在实际电路中断开它</li></ul></li></ul><h2 id="0x04-GPIO口配置"><a href="#0x04-GPIO口配置" class="headerlink" title="0x04 GPIO口配置"></a>0x04 GPIO口配置</h2><blockquote><p>x=0,1,2，前面说过CC2530的IO口被分为3组，P0,P1,P2</p></blockquote><h3 id="1-配置PxSEL寄存器"><a href="#1-配置PxSEL寄存器" class="headerlink" title="1.配置PxSEL寄存器"></a>1.配置PxSEL寄存器</h3><ul><li>端口功能选择，设置端口是普通I/O模式还是外设模式</li></ul><blockquote><p>0–普通I/O模式，1–外设模式，默认是0</p><ul><li>P2只有5个I/O口，P2_1和P2_2专门用于下载程序使用，所以不需要进行设置，P2SEL低三位分别对应P2_0，P2_3，P2_4：<strong>注意是0,3,4而不是3,4,5</strong></li></ul></blockquote><h3 id="2-配置PxDIR寄存器"><a href="#2-配置PxDIR寄存器" class="headerlink" title="2.配置PxDIR寄存器"></a>2.配置PxDIR寄存器</h3><ul><li>作为通用I/O口时，用来设置数据的传输方向，即设置是输出模式还是输入模式</li></ul><blockquote><p>0表示输出模式，1表示输入模式，P2是设置和PxSEL一样</p></blockquote><h3 id="3-配置PxINP寄存器"><a href="#3-配置PxINP寄存器" class="headerlink" title="3.配置PxINP寄存器"></a>3.配置PxINP寄存器</h3><ul><li>在通用输入模式时，决定输入模式是上\下拉还三态模式</li></ul><blockquote><p>0表示上下拉模式，1表示三态模式</p></blockquote><h3 id="4-配置P2INP寄存器"><a href="#4-配置P2INP寄存器" class="headerlink" title="4.配置P2INP寄存器"></a>4.配置P2INP寄存器</h3><ul><li>在上下拉模式确定是上拉模式还是下拉模式</li></ul><blockquote><ul><li>0表示上拉，1表示下拉</li><li>由于P2IO组只有5个IO，所以该寄存器的高3位决定在配置为上下拉模式时，是上拉模式还是下拉模式。</li></ul><blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210526115438650.png" alt="image-20210526115438650"></p><p>如P2INP &amp;= 0xAF(1010 1111),将P0组合P1组引脚设置为上拉模式</p></blockquote></blockquote><h3 id="5-实例代码"><a href="#5-实例代码" class="headerlink" title="5.实例代码"></a>5.实例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P1SEL &amp;= <span class="number">0xFB</span>; <span class="comment">// 1111 1011把P1_2设置为普通IO模式</span></span><br><span class="line">P1DIR &amp;= <span class="number">0xFB</span>; <span class="comment">// 1111 1011把P1_2设置为输入模式</span></span><br><span class="line">P1INP &amp;= <span class="number">0xFB</span>; <span class="comment">// 1111 1011 把P1_2设置为上下拉模式</span></span><br><span class="line">P2INP &amp;= <span class="number">0xBF</span>; <span class="comment">// 1011 1111 把P1设置为上拉模式</span></span><br></pre></td></tr></table></figure><h2 id="0x05-什么是外部中断"><a href="#0x05-什么是外部中断" class="headerlink" title="0x05 什么是外部中断"></a>0x05 什么是外部中断</h2><ul><li>外部中断是单片机实时地处理外部事件的一种内部机制。当某种外部事件发生时，单片机的中断系统将迫使CPU暂停正在执行的程序，转而去进行中断事件的处理；中断处理完毕后．又返回被中断的程序处，继续执行下去。<ul><li>实时处理功能：在实时控制中，现场的各种参数、信息均随时问和现场而变化。这些外界变量可根据要求随时向CPU发出中断申请．请求CPU及时处珲中断请求，如中断条件</li><li>故障处理功能：针对难以预料的情况或故障，如掉电、存储出错、运算溢出等，可通过中断系统由故障源向CPU发出中断请求，再由CPU转到相应的故障处理程序进行处理。</li></ul></li></ul><h2 id="0x06-外部中断配置"><a href="#0x06-外部中断配置" class="headerlink" title="0x06 外部中断配置"></a>0x06 外部中断配置</h2><ul><li>通用 I/O 引脚设置为输入后，可以用于产生中断。</li><li>中断可以设置在外部信号的上升或下降沿触发。 </li></ul><h3 id="1-初始化IO口"><a href="#1-初始化IO口" class="headerlink" title="1.初始化IO口"></a>1.初始化IO口</h3><ul><li>设置IO口为普通IO模式，上拉输入状态</li></ul><blockquote><p>详细信息参考上文IO口配置</p></blockquote><h3 id="2-EA总中断使能-EA"><a href="#2-EA总中断使能-EA" class="headerlink" title="2.EA总中断使能(EA)"></a>2.EA总中断使能(EA)</h3><ul><li><p>.EA总中断是管理着单片机是否执行中断的最大的开关，0为关,1为开</p><blockquote><p>当EA打开时，芯片才会去处理中断请求</p></blockquote></li></ul><h3 id="3-组中断使能-IENx"><a href="#3-组中断使能-IENx" class="headerlink" title="3.组中断使能(IENx)"></a>3.组中断使能(IENx)</h3><ul><li>我们知道21个I/O口是被分为了3个组</li><li>每个组都有一个组中断的开关，控制着该组是否允许执行中断请求</li><li>使能组中断开关需要设置IENI寄存器，如下图所示，IENI寄存器的位与端口组对应，比如我想使能P0组，那么将IENI第六位置为1即可</li></ul><blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210526200715547.png" alt="image-20210526200715547"></p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210526130748589.png" alt="image-20210526130748589"></p><ul><li>从中可以看到IEN1中第5位是P1IE,端口P0组的使能开关控制，IEN2同理</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEN2 |= <span class="number">1</span>&lt;&lt;<span class="number">4</span>; <span class="comment">// 最后得到了0001 0000 1是中断使能，因此就是使能P1端口组</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>ps：听说新一点的iocc2530.h可以使用P0IE,P1IE,P2IE分别控制对应的组中断，但是老一点的必须使用IENx寄存器</p></blockquote><h3 id="4-引脚中断使能-PxIEN"><a href="#4-引脚中断使能-PxIEN" class="headerlink" title="4.引脚中断使能(PxIEN)"></a>4.引脚中断使能(PxIEN)</h3><blockquote><p>除了前面介绍的公共中断使能之外，每个端口还需要进行对应的使能</p></blockquote><ul><li>引脚上有一个中断开关 存于PnIEN使能寄存器中</li><li>针对P0_0~P0_7称为P0IEN，从低到高对应P0_0到P0_7。以此类推还有P1IEN,P2IEN。</li><li>其中P2IEN比较特殊，因为P2组中只有P0-P4五个引脚，其他的是USB等用途</li></ul><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P1IEN |= <span class="number">1</span>&lt;&lt;<span class="number">2</span>; <span class="comment">// 0000 0010 设置P1引脚开关使能</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="5-设置时钟上下沿触发机制-PICTL"><a href="#5-设置时钟上下沿触发机制-PICTL" class="headerlink" title="5.设置时钟上下沿触发机制(PICTL)"></a>5.设置时钟上下沿触发机制(PICTL)</h3><blockquote><p>在计算机中，0是低电平，1是高电平</p></blockquote><ul><li>上升沿：从低电平到高电平的变化   0–&gt;1</li><li>下降沿：从高电平到低电平的变化   1–&gt;0</li></ul><p>在PICTL的前4位存储的就是这种触发时机</p><blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210526195321256.png" alt="image-20210526195321256"></p></blockquote><h3 id="6-设置中断处理函数-interupt"><a href="#6-设置中断处理函数-interupt" class="headerlink" title="6.设置中断处理函数(__interupt)"></a>6.设置中断处理函数(__interupt)</h3><p>将前面配置配置好后便可以编写中断处理函数，声明发生中断时需要做哪些处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize=none <span class="comment">// 不进行编译优化</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=P1INT_VECTOR <span class="comment">// P1组引发中断  PxINT_VECTOR：将x替换为引发中断的组</span></span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">exint</span><span class="params">(<span class="keyword">void</span>)</span>  <span class="comment">// exint函数名可以自定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(P1IFG &amp; <span class="number">0x04</span>) <span class="comment">// 0x04:0000 0100 </span></span><br><span class="line">  <span class="comment">// 这里确定是P1_3发出的中断，P1IFG是P1组的中断标志位，记录每一个引脚是否有中断请求，如果为1，则要中断</span></span><br><span class="line">  &#123;</span><br><span class="line">    delay_ms(<span class="number">100</span>); <span class="comment">// 消抖操作</span></span><br><span class="line">    <span class="keyword">if</span>(P1_2 == <span class="number">0</span>) <span class="comment">// 延时后依旧是低电平，说明确实按下了</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 中断要做的事情</span></span><br><span class="line">      P1_0 = !P1_0;</span><br><span class="line">      P1_1 = !P1_1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 未清除中断状态标志位中断任务会进入死循环</span></span><br><span class="line">  P1IFG = <span class="number">0</span>; <span class="comment">// 把中断状态标志位清0</span></span><br><span class="line">  P1IF = <span class="number">0</span>; <span class="comment">// 组中断标志位清0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="0x07-其他"><a href="#0x07-其他" class="headerlink" title="0x07 其他"></a>0x07 其他</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>使用&amp;、|等运算可以对寄存器数据进行复位，清零，逻辑取反等操作<ul><li>&amp; :  与0为0，与1为本身(复位，清零)</li><li>^ : 异或，相同为假，不同为真( 逻辑取反)</li><li>| : 或1为1，或0为本身</li><li>&lt;&lt; ：左移<ul><li>1&lt;&lt;2：将0x01左移两位得到0x04</li></ul></li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>led_key.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iocc2530.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他注释：state不经常改变的状态，属性、灯的开关等，开了之后就不宜改变</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LED_NUM</span>&#123;</span>LED0,LED1&#125;; <span class="comment">// 枚举0 1 </span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LED_STATE</span>&#123;</span>LED_OFF,LED_ON&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">KEY_STATUS</span>&#123;</span>KEY_DOWM,KEY_UP&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@led_init:对led进行初始化</span></span><br><span class="line"><span class="comment">@retval:null</span></span><br><span class="line"><span class="comment">@note:LED对应的引脚是P1_0和P1_1,初始化为普通IO,输出模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  P1DIR |= <span class="number">0x03</span>;<span class="comment">// 0000 0011 把P1_0和P1_1设置为输出模式</span></span><br><span class="line">  P1SEL &amp;= <span class="number">0xFC</span>;<span class="comment">// 1111 1100 把P1_0和P1_1设置为普通IO模式 </span></span><br><span class="line">  P1_1 = <span class="number">0</span>;</span><br><span class="line">  P1_0 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_ms</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">while</span>(ms--) </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@led_ctrl:对LED状态进行控制函数</span></span><br><span class="line"><span class="comment">@led_num:指定对哪一盏LED等进行控制，可选择为LED0，LED1</span></span><br><span class="line"><span class="comment">@led_state:指定LED的状态，可选择为LED_ON,LED_OFF</span></span><br><span class="line"><span class="comment">@retval :none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_ctrl</span><span class="params">(<span class="keyword">int</span> led_num,<span class="keyword">int</span> led_state)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(led_num) &#123;</span><br><span class="line">    <span class="keyword">case</span> LED0:</span><br><span class="line">      P1_0 = led_state;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LED1:</span><br><span class="line">      P1_1 = led_state;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@key_init:按键的初始化函数</span></span><br><span class="line"><span class="comment">@note:按键对应的引脚是P1_2，应初始化为普通IO,上拉输入模式</span></span><br><span class="line"><span class="comment">@retval :none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  P1SEL &amp;= <span class="number">0xFB</span>; <span class="comment">// 1111 1011把P1_2设置为普通IO模式</span></span><br><span class="line">  P1DIR &amp;= <span class="number">0xFB</span>; <span class="comment">// 1111 1011把P1_2设置为输入模式</span></span><br><span class="line">  P1INP &amp;= <span class="number">0xFB</span>; <span class="comment">// 1111 1011 把P1_2设置为上下拉模式</span></span><br><span class="line">  P2INP &amp;= <span class="number">0xBF</span>; <span class="comment">// 1011 1111 把P1设置为上拉模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@keystatus:获取按键的状态</span></span><br><span class="line"><span class="comment">@retval :按键按下返回KEY_DOWN,按键松开返回KEY_UP</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">key_status</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(P1_2 == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> KEY_DOWM;</span><br><span class="line">  &#125; <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> KEY_UP ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize=none <span class="comment">// 不进行编译优化</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=P1INT_VECTOR <span class="comment">// P1组引发中断</span></span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">exint</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(P1IFG &amp; <span class="number">0x04</span>) <span class="comment">// 0000 0100</span></span><br><span class="line">  &#123;</span><br><span class="line">    delay_ms(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(P1_2 == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 中断要做的事情</span></span><br><span class="line">      P1_0 = !P1_0;</span><br><span class="line">      P1_1 = !P1_1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  P1IFG = <span class="number">0</span>; <span class="comment">// 把中断状态标志位清0</span></span><br><span class="line">  P1IF = <span class="number">0</span>; <span class="comment">// 组中断标志位清0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@exit_init:外部中断初始化函数</span></span><br><span class="line"><span class="comment">@retval :none</span></span><br><span class="line"><span class="comment">@note:对应的引脚是P1_2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// (1)初始化IO口工作在普通IO模式，上拉输入状态</span></span><br><span class="line">  key_init();</span><br><span class="line">  <span class="comment">// (2)首先打开IO口组中断允许位===&gt;P1IE</span></span><br><span class="line">  IEN2 |= <span class="number">1</span>&lt;&lt;<span class="number">4</span>;</span><br><span class="line">  <span class="comment">// (3)打开组内对应的具体某IO口中断====&gt;PxIEN</span></span><br><span class="line">  P1IEN |= <span class="number">1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">  <span class="comment">// (4)设置是上升沿还是下降沿触发===&gt;PICTL(0,代表上升沿触发；1，代表下降沿触发)</span></span><br><span class="line">  PICTL |= <span class="number">0x02</span>; <span class="comment">// 0000 0010 设置为下降沿触发==&gt;PICTL(0,代表)</span></span><br><span class="line">  <span class="comment">// (5)打开CPU总中断 EA=1;</span></span><br><span class="line">  EA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>led_key.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LED_KEY_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LED_KEY_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iocc2530.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LED_NUM</span>&#123;</span>LED0,LED1&#125;; <span class="comment">// Ã¶¾Ù0 1 </span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LED_STATE</span>&#123;</span>LED_OFF,LED_ON&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">KEY_STATUS</span>&#123;</span>KEY_DOWM,KEY_UP&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">led_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">led_ctrl</span><span class="params">(<span class="keyword">int</span> led_num,<span class="keyword">int</span> led_state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">key_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">key_status</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">exit_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h3><ul><li>内容不多，感觉学起来挺简单的，用起来还是不知道怎么搞，而且背后的内容如果更细一点，估计要学的内容够呛</li><li>还有感觉学的时候有点钻牛角尖，有的时候会情不自禁的想要了解更多背后的细节，然后emmmmmm，又入门到精通，很多东西其实只要知道如何使用，有个大概了解即可</li><li>今日份开心：获得一篇文章的优先读取权，文章某人还在构思中</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="http://ai.baidu.com/forum/user/center/2312565">Zigbee学习日记（四）外部中断</a> </p><p><a href="https://zhuanlan.zhihu.com/p/345062445">CC2530最小系统搭建</a></p><p><a href="https://www.cnblogs.com/yuling520/p/12663094.html">CC2530通用IO口的输入输出</a></p>]]></content>
      
      
      <categories>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实训 </tag>
            
            <tag> CC2530 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实训Day01</title>
      <link href="2021/05/24/09%E5%AE%9E%E8%AE%ADDay01/"/>
      <url>2021/05/24/09%E5%AE%9E%E8%AE%ADDay01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本周主要是学习关于Zigbee的自组网，今天是第一天，都是些简单的环境配置和运行</p></blockquote><h2 id="0x01-什么是Zigbee"><a href="#0x01-什么是Zigbee" class="headerlink" title="0x01 什么是Zigbee"></a>0x01 什么是Zigbee</h2><ul><li>Zigbee：近距离、低复杂的双信通信系统</li><li>本质：无线设备之间得到通信方式 </li><li>用途：用于短距离、低功耗、传输效率低电子设备之间数据传输</li><li>特点：低功耗、低成本、大容量、时延短、可靠性高、网络拓扑结构灵活 </li><li>缺点：通信速率比较小</li><li>主要作用：构建无线局域网</li><li>其他：Zigbee、Zigbee协议、Zigbee通信方式是一回事</li><li>注意：Zigbee只是用来完成数据通信的工作，具体使用的功能系统取决于上位机计算机</li></ul><h2 id="0x02-无线通信方式对比"><a href="#0x02-无线通信方式对比" class="headerlink" title="0x02 无线通信方式对比"></a>0x02 无线通信方式对比</h2><ul><li>蓝牙：功耗比较低(相对于Zigbee)，组建网络节点数少(7~8)</li><li>WiFi：通信速率比较大，功耗大</li><li>Zigbee：组建大规模网络，且功耗低，缺点：通信速率比较小</li></ul><h2 id="0x03-Zigbee环境安装"><a href="#0x03-Zigbee环境安装" class="headerlink" title="0x03 Zigbee环境安装"></a>0x03 Zigbee环境安装</h2><ol><li><p>环境工具</p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210524182058679.png" alt="image-20210524182058679"></p></li><li><p>双击安装包后，先后出现下面左边的两个画面时，以<strong>管理员身份</strong>运行注册工具，记得<strong>关闭安全软件</strong></p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210524182434523.png"></p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210524182533660.png" alt="image-20210524182533660"></p></li><li><p>一直下一步即可</p></li></ol><h2 id="0x04-IAR工程建立"><a href="#0x04-IAR工程建立" class="headerlink" title="0x04 IAR工程建立"></a>0x04 IAR工程建立</h2><ol><li><p>先创建一个工作空间</p><p>步骤：File–&gt;new–&gt;workspace</p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210524182703229.png" alt="image-20210524182703229"></p></li><li><p>创建一个工程</p><p>Project–&gt;Create New Project–&gt;Empty project–&gt;0K–&gt;保存</p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210524182815959.png" alt="image-20210524182815959"></p></li><li><p>新建一个文件–&gt;保存为.c文件</p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210524182901492.png" alt="image-20210524182901492"></p></li></ol><p>​    Crtl+s保存，后缀.c</p><ol start="4"><li><p>将.c文件添加进工程</p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210524183025818.png" alt="image-20210524183025818"></p></li><li><p>保存工作空间</p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210524183113154.png" alt="image-20210524183113154"></p><p>或者直接关闭时候选择保存</p></li><li><p><strong>编译和仿真</strong></p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210524190237177.png" alt="image-20210524190237177"></p></li></ol><h2 id="0x05-选项配置"><a href="#0x05-选项配置" class="headerlink" title="0x05 选项配置"></a>0x05 选项配置</h2><ul><li><p>选择“工程名-Debug”–&gt;options</p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210524183306665.png" alt="image-20210524183306665"></p></li></ul><ol><li><p>General Options–&gt;Device 选择Texas Instruments–&gt;cc2530F256</p><p><img src="../../../../../%E5%9B%BE%E7%89%87/%E8%B5%84%E6%96%99/01Typora%E4%BF%9D%E5%AD%98/image-20210524183511254.png" alt="image-20210524183511254"></p></li><li><p>)Linker–&gt;Output–&gt;Override default勾上</p><p> Allow C-SPY-specific extra output file 勾上</p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210524183611570.png" alt="image-20210524183611570"></p></li><li><p>Debugger–&gt;Driver–&gt;选择Texas Instrments</p><p><img src="../../../../../%E5%9B%BE%E7%89%87/%E8%B5%84%E6%96%99/01Typora%E4%BF%9D%E5%AD%98/image-20210524183703336.png" alt="image-20210524183703336"></p></li></ol><blockquote><p>这些选项设置不配置好，后续下载编译或调试时会出错</p></blockquote><ol start="4"><li>生成Hex文件的设置</li></ol><p>Linker–&gt;Extra Output–&gt;Genetare extra output file【勾上】–&gt;</p><p> Override defualt【勾上】–&gt;命名为.hex文件</p><p>  output format :intel-extended–&gt;OK</p><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210524185648418.png" alt="image-20210524185648418"></p><blockquote><p><strong>再次编译后会在项目空间的Debuh/Exe目录下生成hex文件</strong>，烧录的时候往下面去找即可</p></blockquote><h2 id="0x06-驱动安装"><a href="#0x06-驱动安装" class="headerlink" title="0x06 驱动安装"></a>0x06 驱动安装</h2><blockquote><p>别问，问就是上课在睡觉，没截图</p></blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210524190051022.png" alt="image-20210524190051022"></p><h2 id="0x07-文件烧录"><a href="#0x07-文件烧录" class="headerlink" title="0x07 文件烧录"></a>0x07 文件烧录</h2><ul><li>安装烧录软件SmartRFProgram</li></ul><blockquote><p>双击一直下一步</p></blockquote><ul><li>烧录</li></ul><blockquote><p>烧录前需要重置仿真器，烧录出错须注意下仿真器是否重置，同时烧录的时候需要终止IAR Embedded的仿真</p></blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/%E7%89%A9%E8%81%94%E7%BD%91%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD/image-20210524184229969.png" alt="image-20210524184229969"></p><h2 id="0x08-LED灯闪烁"><a href="#0x08-LED灯闪烁" class="headerlink" title="0x08 LED灯闪烁"></a>0x08 LED灯闪烁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iocc2530.h&quot;</span></span></span><br><span class="line"><span class="comment">// 点亮两盏LED灯</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_ms</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">while</span>(ms--) </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">275</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  P1_0 = <span class="number">0</span>;</span><br><span class="line">  P1_1 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  P1DIR |= <span class="number">0x03</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    led_init();</span><br><span class="line">    delay_ms(<span class="number">500</span>);</span><br><span class="line">    P1_0 = <span class="number">1</span>;</span><br><span class="line">    P1_1 = <span class="number">1</span>;</span><br><span class="line">    delay_ms(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实训 </tag>
            
            <tag> Zigbee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随手感慨</title>
      <link href="2021/05/20/08%E9%9A%8F%E5%90%8E%E6%84%9F%E6%85%A8/"/>
      <url>2021/05/20/08%E9%9A%8F%E5%90%8E%E6%84%9F%E6%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="关于男女关系的理解"><a href="#关于男女关系的理解" class="headerlink" title="关于男女关系的理解"></a>关于男女关系的理解</h1><p>​    在以前的时候就听八卦爆出杜海涛和沈梦辰爱情长跑最后分手，华晨宇和张碧晨未婚先孕人设崩塌。但是因为我这个人对身边的很多事情都不感兴趣，尤其是娱乐圈，因此就没有过多在意。但是今天看了几个关于这些瓜的分析后不经有些感慨。</p><ul><li><p>首先我对杜海涛和华晨宇都只是有个固有印象，一个憨厚的舞台配角和孤僻的华语才子，这些印象是很早以前通过电视节目形成的，一直没变过，在我心目中这个两个人的好感度还是挺高的，尤其是华晨宇，但是…….</p><blockquote><p>声明：所有感慨和诉说事情均来自网络中看到的相关报道，未经考证，真真假假，留待众人分说。只想表达一个核心感慨而已，娱乐圈就是一场低分电影，里面的明星不过是饰演出来人物角色而已，都是人设和幻象。</p></blockquote></li><li><p>杜海涛，他，资产过亿，”商业才子“，名门之后，顶流明星。在知道他利用憨厚人设大肆流量变现和商业投资后，我就明白了这家伙是个人精，双重面孔，准确来讲，屏幕上展现的杜海涛不过是他饰演的一个角色而已，演了十几年，假的还是没有成真。说说他的丑闻，13年打人事件，权志龙下跪献花事件(最离谱还是回怼网友)，柳岩伴娘事件，这些东西尤其是最后一个在我知道后我就对这个角色没有任何的好感度了，只是角色永远都不缺喜欢的人。</p></li><li><p>华晨宇，他，我就要多说一点了，因为他竟然曾经和邓紫棋在一起过，就离谱，因为我是从初中开始就一直喜欢邓紫棋这个角色的，一直到高中毕业吧！然后就是和张碧晨生了娃，看过张碧晨发的声明，发现这个设定自闭恐女的角色是个人精啊，至于有咩有PUA这些东西就没有人知道了。还有邓紫棋画这首歌竟然是写个这个角色的，爷吐了，不过，倒也无所谓了。</p></li><li><p>关于男女关系，之所以会说这个，是因为无论是杜海涛还是华晨宇，在他们的关系里面女方都是卑微的，沈梦辰有没有心机我不知道，但我觉得的是杜海涛对于这段关系是没有在意的。至于华晨宇，嗯，离谱，跟他的孤僻自闭设定相差太远。</p></li></ul><p>我觉得爱情和正常的男女关系双方应该是平等的，没有谁卑微这一说法，所谓相敬如宾就是如此。</p><blockquote><p>好了，想到哪写到哪，没有逻辑和整理，看官自由分说。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
            <tag> 与我无关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学试卷做题记录</title>
      <link href="2021/05/17/07%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E8%AF%95%E5%8D%B7%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>2021/05/17/07%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E8%AF%95%E5%8D%B7%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><h3 id="第1题"><a href="#第1题" class="headerlink" title="第1题"></a>第1题</h3><ul><li><p>知识点1</p><p>   设A为任一命题公式</p><ul><li><p>重言式（永真式）：A在它的各种赋值下取值均为真</p></li><li><p>矛盾式（永假式）：A在它的各种赋值下取值均为假</p></li><li><p>可满足式：非矛盾式则为可满足式</p><blockquote><p>重言式一定是可满足式</p></blockquote></li></ul></li><li><p>知识点2</p><ul><li>蕴含式：p-&gt;q<ul><li>只有p为真且q为假时p-&gt;q为假</li></ul></li><li>合取式：p∧q<ul><li>只有p和q都为真的时候p∧q才为真</li></ul></li><li>析取式：pVq<ul><li>只有p和q都为假的时候pVq才为假</li></ul></li><li>否定式：非p<ul><li>p为真，非p为假的</li></ul></li></ul></li><li><p>解题      B</p><blockquote><p>找出一种赋值下结果为假即可排除</p><p>A.        P=1,Q=0;P-&gt;Q为假，P-&gt;(P-&gt;Q)为假</p><p>B.        要想整体为假，则Q必须为0，前部分整体为真，即P必须为1；</p><p>将P=1,Q=0带入发现整体为真，因此为永真式</p><p>c.        P=1,Q=0</p><p>D.        P=1,Q=0</p></blockquote></li></ul><h3 id="第2题"><a href="#第2题" class="headerlink" title="第2题"></a>第2题</h3><ul><li><p>判断各非负整数列是否可简单图化</p><ol><li>非负整数列之和为偶数才可图化</li><li>最大度&lt;=顶点数-1</li><li>根据度数画出图观察是否为简单图</li></ol><blockquote><p>简单图：不含平行边和顶点自身的环</p></blockquote></li><li><p>解题 D</p><ul><li>根据1排除B，根据步骤2排除A，根据步骤3排除C</li></ul></li></ul><h3 id="第3题"><a href="#第3题" class="headerlink" title="第3题"></a>第3题</h3><ul><li><p>知识点（P125）</p><ul><li><p>自反： 如果a是A的元素，那么&lt;a,a&gt;是R的元素</p><blockquote><p>每个顶点都有环</p></blockquote></li><li><p>反自反：如果a是A的元素，那么&lt;a,a&gt;不是R的元素</p><blockquote><p>每个顶点都没有换</p></blockquote></li><li><p>对称： 如果&lt;a,b&gt;是R的元素，那么&lt;b,a&gt;是R的元素</p></li><li><p>反对称：如果&lt;a,b&gt;，&lt;b,a&gt;是R的元素，那么a,b相等</p><blockquote><p>只有单向边</p></blockquote></li><li><p>传递： 如果&lt;a,b&gt;，&lt;b,c&gt;是R的元素，那么&lt;a,c&gt;是R的元素</p></li></ul></li><li><p>解题    D</p><blockquote><p>A:反自反</p><p>B:反自反</p><p>C:传递性</p></blockquote></li></ul><h3 id="第4题"><a href="#第4题" class="headerlink" title="第4题"></a>第4题</h3><ul><li><p>解题    D</p></li><li><p>集合中可定义多少个不同的等价关系</p><ul><li>集合划分,举例说明</li><li>A={1,2}    (总计2个等价关系) {[1],[2]}  |  {[1,2]}</li><li>A={1,2,3}    (总计5个等价关系) {[1],[2],[3]}   |  {[1,2],[3]}  |  {[1,3],[2]}  |  {[2,3],[1]}  |  {[1,2,3]}</li></ul><blockquote><p>为方便辨认，将集合内部集合的{}用[]进行替换</p></blockquote></li></ul><h3 id="第5题"><a href="#第5题" class="headerlink" title="第5题"></a>第5题</h3><ul><li><p>知识点</p><ul><li>和第一题一样</li><li>可将00,01,10,11分别代入看有几个真</li></ul></li><li><p>解题    C</p></li></ul><h3 id="第6题"><a href="#第6题" class="headerlink" title="第6题"></a>第6题</h3><ul><li><p>知识点(P8)</p><ul><li>命题必须是陈述句    排除A</li><li>命题必须能确定真假    排除B(B无法确定真假)</li><li>当且仅当：&lt;-&gt;(等价联结词)<ul><li>p&lt;-&gt;q只有当p和q都为真或都为假的时候才为真</li></ul></li><li>只有…才….：–&gt;（蕴含联结词）<ul><li>只有p为真，q为假是p–&gt;q才为假</li></ul></li></ul></li><li><p>解题    此题感觉都不符合</p><ul><li>C选项p为真，q为假，整体为假</li><li>D选项p为真，q为假，整体为假</li></ul></li></ul><h3 id="第7题"><a href="#第7题" class="headerlink" title="第7题"></a>第7题</h3><ul><li><p>知识点(P301)</p><ul><li><p>点割集：删除某几个点能够使得图的连通分支增加的点集合</p><blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/01%E8%80%83%E8%AF%95/image-20210517221006449.png" alt="image-20210517221006449"></p></blockquote></li><li><p>点连通图：使连通图G成为一个不连通图需要删除的点的最小数目，记为K，则图也可称作K-连通图</p></li><li><p>边连通图：使连通图G成为一个不连通图需要删去的边的最少数目，记为R，则图也可称作R边-连通图</p></li><li><p>彼得森图：</p><blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/01%E8%80%83%E8%AF%95/image-20210517221426549.png" alt="image-20210517221426549"></p></blockquote></li></ul></li><li><p>解题     A</p><ul><li>删除上图中紫色的3条边可以使得此图不再连通</li><li>删除绿色框框标记的3个点可以使得此图不再连通</li></ul></li></ul><h3 id="第8题"><a href="#第8题" class="headerlink" title="第8题"></a>第8题</h3><ul><li><p>知识点(P113)</p><ul><li>恒等关系l(A)={&lt;x,x&gt;|x属于A}</li><li>全域关系E(A)={&lt;x,y&gt; | x属于A并且y属于A}=*<em>A</em>A**</li><li>(集合之间相乘)<ul><li>A={a,b},B={c,d}</li><li>A*B={&lt;a,c&gt;,&lt;a,d&gt;,&lt;c,a&gt;,&lt;c,d&gt;}</li></ul></li></ul></li><li><p>解题    D</p><blockquote><p>求出全域关系后和第一题知识点一样</p></blockquote></li></ul><h3 id="第9题"><a href="#第9题" class="headerlink" title="第9题"></a>第9题</h3><ul><li>知识点<ul><li>欧拉公式：边划分的区域数+顶点数=边数+2</li></ul></li><li>解题    D</li></ul><h3 id="第10题"><a href="#第10题" class="headerlink" title="第10题"></a>第10题</h3><ul><li><p>知识点</p><ul><li>集合和集合之间是包含关系，注意{a,b}属于{a,b,{a,b}}也是正确的</li></ul></li><li><p>解题    C</p></li></ul><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><h3 id="第1题-1"><a href="#第1题-1" class="headerlink" title="第1题"></a>第1题</h3><ul><li>知识点(P50)   推理公式</li><li>解题：  A-&gt;C</li></ul><h3 id="第2题-1"><a href="#第2题-1" class="headerlink" title="第2题"></a>第2题</h3><ul><li>知识点：直接除以7模是3组成的集合   </li><li>解题：  {3,7}</li></ul><h3 id="第3题-1"><a href="#第3题-1" class="headerlink" title="第3题"></a>第3题</h3><ul><li><p>知识点</p><blockquote><p>以图G为例子</p></blockquote><ul><li>连通图：图G是平凡图或者任何两个顶点都是连通的<ul><li>平凡图：只有一个结点的图</li></ul></li><li>强连通图：有向图中任意两个顶点中存在互相连通的路径</li><li>哈密顿图：拥有哈密顿回路的图<ul><li>哈密顿回路：经过图中所有顶点一次且仅一次的回路</li></ul></li></ul></li><li><p>答案：假，0–&gt;不一定存在回路</p></li></ul><h3 id="第4题-1"><a href="#第4题-1" class="headerlink" title="第4题"></a>第4题</h3><ul><li><p>知识点：P64，P75</p></li><li><p>解题：∃x(F(x)–&gt;G(x))</p></li></ul><h3 id="第5题-1"><a href="#第5题-1" class="headerlink" title="第5题"></a>第5题</h3><ul><li><p>知识点：P95</p><ul><li>A⊕B=(A-B)U(B-A)</li><li>A⊕A=(A-A)U(A-A)=Ø</li></ul></li><li><p>解题：Ø</p></li></ul><h3 id="第6题-1"><a href="#第6题-1" class="headerlink" title="第6题"></a>第6题</h3><ul><li><p>知识点：P92</p><ul><li>看答案有四个，一般会认为只有三个</li></ul></li><li><p>解题：{Ø，{Ø}，，{Ø，{Ø}} }</p></li></ul><h3 id="第7题-1"><a href="#第7题-1" class="headerlink" title="第7题"></a>第7题</h3><ul><li><p>知识点：P74</p><ul><li>直接根据书上的公式进行变化</li><li>前束范式：Q1X1Q2x2…Q(k)x(k)</li><li>注意前束范式的形式即可</li></ul></li><li><p>解题：∀x∃y(¬F(x,y))</p></li></ul><h3 id="第8题-1"><a href="#第8题-1" class="headerlink" title="第8题"></a>第8题</h3><ul><li>知识点：P307<ul><li>二部图：将图的节点V分为两个节点集V1和V2,图中每条边的两个端点都是一个属于V1,另一个属于V2</li><li>完全二部图：V1中每个顶点均与V2中的每个顶点相邻，即V1中每个顶点和V2中的所有顶点之间都存在边</li><li>欧拉回路(P316)：通过图中所有边一次且仅一次行遍所有顶点的通路</li><li>因此这个题就是求图总共有多少条边</li></ul></li><li>解题：r*s<ul><li>完全二部图，所以将图中顶点分为V1和V2,然后V1中所有顶点和V2中的所有顶点之间都存在边</li><li>因此总共含有的边数就是：V1*V2</li></ul></li></ul><h3 id="第9题-1"><a href="#第9题-1" class="headerlink" title="第9题"></a>第9题</h3><ul><li><p>知识点：P74</p><ul><li>做题时候直接翻书带公式</li></ul></li><li><p>解题：∀xA(x)∧B</p></li></ul><h3 id="第10题-1"><a href="#第10题-1" class="headerlink" title="第10题"></a>第10题</h3><ul><li><p>知识点：P297</p><ul><li>任何无向图中所有顶点的度数之和是边数的两倍</li><li>任何有向图中所有顶点的度数之和是边数的两倍，所有入度之和等于出度之和等于边数</li></ul></li><li><p>解题：   7</p><blockquote><p>10条边：因此所有顶点度数之和为20，减去已知度数(3 * 2+4 * 2=14)，剩余6</p><p>已知其余顶点的度数都小于3，求至少的顶点数，因此假设其余顶点度数为最大，小于3因此取2，</p><p>6/2=3，其余顶点数为3，因此所有顶点数之和为7</p></blockquote></li></ul><h2 id="解答题"><a href="#解答题" class="headerlink" title="解答题"></a>解答题</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>P28-P29</p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><ul><li>哈斯图相关知识点介绍</li></ul><blockquote><p><a href="https://blog.csdn.net/qq_26816591/article/details/46873463?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-1&spm=1001.2101.3001.4242">离散数学偏序关系哈斯图上（下）确界极小（大）值最大（小）值</a></p></blockquote><blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/01%E8%80%83%E8%AF%95/image-20210517235303589.png" alt="image-20210517235303589"></p></blockquote><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>根据哈斯图进行求解</p><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>P22等推理公式进行求解</p>]]></content>
      
      
      <categories>
          
          <category> 期末考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散数学 </tag>
            
            <tag> 期末考试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>占用位置</title>
      <link href="2021/05/12/06%E5%8D%A0%E7%94%A8%E4%BD%8D%E7%BD%AE2/"/>
      <url>2021/05/12/06%E5%8D%A0%E7%94%A8%E4%BD%8D%E7%BD%AE2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>占用位置</title>
      <link href="2021/05/11/05%E5%8D%A0%E7%94%A8%E4%BD%8D%E7%BD%AE/"/>
      <url>2021/05/11/05%E5%8D%A0%E7%94%A8%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>node编译工具node-gyp相关错误</title>
      <link href="2021/05/10/04npm-node%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>2021/05/10/04npm-node%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="node编译工具node-gyp相关错误"><a href="#node编译工具node-gyp相关错误" class="headerlink" title="node编译工具node-gyp相关错误"></a>node编译工具node-gyp相关错误</h1><h3 id="错误1：gyp-ERR-stack-Error-spawn-E-Software3-VisualStudio-IDE-MSBuild-15-0-Bin-MSBuild-exe-ENOENT"><a href="#错误1：gyp-ERR-stack-Error-spawn-E-Software3-VisualStudio-IDE-MSBuild-15-0-Bin-MSBuild-exe-ENOENT" class="headerlink" title="错误1：gyp ERR! stack Error: spawn E:\Software3\VisualStudio\IDE\MSBuild\15.0\Bin\MSBuild.exe ENOENT"></a>错误1：gyp ERR! stack Error: spawn E:\Software3\VisualStudio\IDE\MSBuild\15.0\Bin\MSBuild.exe ENOENT</h3><blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/image-20210510101314896.png" alt="image-20210510101314896"></p></blockquote><ul><li>原因：这个问题应该是node-gyp找不到编译工具引发的(VisualStudio–&gt;可能是和C++编译工具有关)</li></ul><blockquote><p>node-gyp是一个编译工具，负责将源码形式的node modules编译成适应于本地环境的、编译好的node modules，其中的编译过程就需要依赖一些编译工具（环境），如c编译器和python环境</p></blockquote><ul><li><strong>解决</strong>：安装windows-build-tools构建工具即可(注意大小写)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global --production windows-build-tools --vs2017</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://mikasae.github.io/Mikasa/boke/image-20210510101929105.png" alt="image-20210510101929105"></p></blockquote><ul><li>问题解决可以参考</li></ul><p><a href="https://github.com/nodejs/node-gyp/issues/1747">MSBuild.exe ENOENT-使用VS2019而不是VS2017 </a></p><p><a href="https://www.npmjs.com/package/windows-build-tools">安装windows-build-tools工具</a></p><ul><li><p>其他</p><ul><li><p>这个问题是我在安装node-sass插件中出现的，node-sass的使用也是需要依赖具体编译环境的，因此如果没有构建工具或者编译环境有问题就会出现各种各样的错误</p></li><li><p>因此使用安装node-sass，建议先安装构建环境，如果使用过程中出现问题优先考虑是不是编译环境出问题了</p></li><li><p>node-gyp这个编译工具是依赖于多种编译环境的如python,c等</p></li></ul><blockquote><p>从安装sass的那一天起，我的npm工具不管输入什么命令，就开始疯狂报错，我还以为是我的环境出问题了，还在犹豫要不要重装。—-&gt;然后重点来了，在安装完这个构建工具后，我的npm工具好了。。。。好了。。。。。(tm)它好了,emmmmm，如下</p><p><img src="https://mikasae.github.io/Mikasa/boke/image-20210510103303381.png" alt="image-20210510103303381"></p><p>所以我估摸着就是sass需要依赖特定的编译环境，而我的电脑的编译环境有问题，node-gyp编译工具编译出错了，所以才会导致各种各样的问题</p></blockquote><blockquote><p>还有一点，这里只是简单的了解和解决问题，我有预感以后还会出现新的问题，那时候应该必须仔细了解node-gyp编译和编译环境才能解决。谁知道呢？</p></blockquote></li></ul><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> 报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/09/03Git%E4%BD%BF%E7%94%A8/"/>
      <url>2021/05/09/03Git%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><ul><li>项目目录下初始化本地仓库(Git代码库)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>添加文件到暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line">git add 文件1 文件2 文件3...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">git add [dir]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录所有文件到暂存区</span></span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><ul><li>将暂存区文件添加到本地仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;备注信息&quot;</span><br></pre></td></tr></table></figure><ul><li><p>远程同步</p><ul><li>remote</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示所有远程仓库（-v参数会显示详细信息）</span></span><br><span class="line">git remote -v </span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加一个新的远程仓库，并指定一个方便使用的简写代替</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 仓库url:git@github_remmeiko:xxx/xxx.git</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 简写shortname：可随便指定</span></span><br><span class="line">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure><ul><li>push</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将本地仓库的文件推送到远程分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果远程仓库没有这个分支，会新建一个同名的远程分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果省略远程分支名，则表示两者同名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin branchname</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果省略本地分支名，则表示删除指定的远程分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 因为这等同于推送一个空的本地分支到远程分支。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立当前分支和远程分支的追踪关系</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果当前分支与远程分支之间存在追踪关系</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 则可以省略分支和 -u</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push --all origin</span></span><br></pre></td></tr></table></figure><ul><li>pull</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取所有远程分支到本地镜像仓库中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取并合并项目其他人员的一个分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull origin branchname</span></span><br></pre></td></tr></table></figure></li><li><p>查看信息</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看代码修改情况（工作区，暂存区，本地仓库）</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有配置信息</span></span><br><span class="line">git config --list</span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地仓库用户名和邮箱</span></span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br><span class="line"><span class="meta">#</span><span class="bash"> 全局配置</span></span><br><span class="line">git config --global user.name</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure><ul><li>设置用户名和邮箱</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 本地仓库用户名和邮箱</span></span><br><span class="line">git config user.name &quot;用户名&quot;</span><br><span class="line">git config user.email &quot;邮箱&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 全局配置</span></span><br><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><ul><li>删除用户名和邮箱</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 本地仓库用户名和邮箱</span></span><br><span class="line">git config --unset user.name &quot;用户名&quot;</span><br><span class="line">git config --unset user.email &quot;邮箱&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 全局配置</span></span><br><span class="line">git config --global --unset user.name &quot;用户名&quot;</span><br><span class="line">git config --global --unset user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><ul><li>分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支和远程分支</span></span><br><span class="line">git branch -a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个本地分支，依然停留在本分支   [branch-name]:分支名字</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换分支</span></span><br><span class="line">git checkout [branch-name]</span><br><span class="line">M CrawierMaven/DownloadMaven/Frame.java # M是带过来上个分支的修改</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地分支</span></span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line">git branch -r -d origin/[branch-name]</span><br><span class="line">git push origin --delete 【branch-name】</span><br></pre></td></tr></table></figure><ul><li>tag</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">git push origin :refs/tags/【tag名】</span><br><span class="line"><span class="comment"># 创建tag</span></span><br><span class="line">git tag -a 【tag名】 -m 【备注】</span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">git tag -d 【tag名】</span><br><span class="line"><span class="comment"># 在github制作tag的步骤</span></span><br><span class="line"><span class="comment"># 1.创建tag</span></span><br><span class="line"><span class="comment"># 2.上传tag</span></span><br><span class="line">git push orgin 【tag名】</span><br></pre></td></tr></table></figure><ul><li>分支合并</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将remmeiko分支合并到main</span></span><br><span class="line"><span class="comment"># 1.首先进入main分支合并remmeiko分支</span></span><br><span class="line">git merge remmeiko</span><br><span class="line"><span class="comment"># 2.查看合并状态是否存在冲突</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 3.解决冲突后添加</span></span><br><span class="line">git add ...</span><br><span class="line">git commit -m <span class="string">&quot;...&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/08/01hello-world/"/>
      <url>2021/05/08/01hello-world/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章我会一直续写下去的，心事，感悟都可以，毕竟一辈子很短，我还想去看看更多有趣的事，去见更多有趣的人。</p><p>Hello world，世界，你好，往后余生，还请多担待。</p></blockquote><h2 id="0x01-前情说明"><a href="#0x01-前情说明" class="headerlink" title="0x01 前情说明"></a>0x01 前情说明</h2><ul><li><p>创建此博客的初衷在于每天记录一点新东西，督促自己每天都要进步</p></li><li><p>当累计到合适的时候，我会将其进行汇总归纳发布到我的另一个<a href="https://remmeiko.buzz/">博客网站</a></p></li><li><p>看到学相伴阿超大佬每天都会发布一篇博客，并且能够保持健康规律的生活，希望能够向他学习</p></li></ul><h2 id="0x02-我现阶段的小理想"><a href="#0x02-我现阶段的小理想" class="headerlink" title="0x02 我现阶段的小理想"></a>0x02 我现阶段的小理想</h2><ul><li>现在的我希望能够找到一份满意的工作，生活能够不慌不忙不卑不吭，工作不一定要钱多，不一定要事少，只要我内心觉得满意就行(很抽象)。</li><li>具体描述的话，emmm……我想一想，写字楼？与周围人好好相处？平均水平的工资？对了，一定要有上升空间和进取的态度。</li><li>如果什么时候我开始真正的佛系，或许不是我看开了，而是我这一辈子已经能够看到彼岸，那时候每天可能就在流水线也说不定，若果真如此那人生真就已经一眼望穿了。（呸呸呸，想啥呢？扯远了扯远了，这样一辈子太无聊了）</li></ul><h2 id="0x03-我追求的啊"><a href="#0x03-我追求的啊" class="headerlink" title="0x03 我追求的啊"></a>0x03 我追求的啊</h2><ul><li><p>我只想<strong>将复杂的人生过的简单，将平凡的生活过得精彩</strong></p><blockquote><p>我在想啊，人生太复杂，要是所有的事情都能总结出”套路“，变成一个习惯，那不就简单了吗？哈，再加上强迫症就能将生活过的稍微那么精致一点，</p></blockquote></li><li><p><strong>健身和学习是唯一付出就有回报的投资</strong></p><blockquote><p>生活中大佬太多了而且都很低调，你永远不知道你身边走过去的那个普通的小子有多牛逼，所以只有不断学习才能不断进步，去看更远的地方    </p></blockquote><ul><li>学习是让自己安静下来，健身是为了让自己冷静下来</li></ul><blockquote><p>当然了，现在在考研，健身是不可能健身的，唯一能坚持就是在一天过完后做做俯卧撑，引体向上之类的而已。</p></blockquote><p>​                                                                                                            —–20210513</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置 多个GitHub账号</title>
      <link href="2021/05/08/02%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7/"/>
      <url>2021/05/08/02%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="一台电脑-配置多个GitHub账号"><a href="#一台电脑-配置多个GitHub账号" class="headerlink" title="一台电脑 配置多个GitHub账号"></a>一台电脑 配置多个GitHub账号</h1><blockquote><p>假设配置的两个GitHub账号分别为remmeiko和Mikasa</p><p>操作环境：Windows</p></blockquote><h2 id="0x01-生成密钥"><a href="#0x01-生成密钥" class="headerlink" title="0x01.生成密钥"></a>0x01.生成密钥</h2><blockquote><p>每一个GitHub账号可以有多个ssh key,但是一个ssh key只能用于一个GitHub账号，所以需要为每个GitHub账号生成对应的ssh key</p></blockquote><h3 id="1-生成第一个账号rem的密钥"><a href="#1-生成第一个账号rem的密钥" class="headerlink" title="1.生成第一个账号rem的密钥"></a>1.生成第一个账号rem的密钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “邮箱1”</span><br></pre></td></tr></table></figure><blockquote><p>此处虽然没有加-f参数，但执行时自动选择路径并命名(会向你确认一下路径)</p></blockquote><ul><li>执行完后会在【C:\Users\用户\ .ssh】路径生成id_rsa(密钥)和id_rsa.pub(公钥)两个文件</li></ul><h3 id="2-生成第二个账号rem2的密钥"><a href="#2-生成第二个账号rem2的密钥" class="headerlink" title="2.生成第二个账号rem2的密钥"></a>2.生成第二个账号rem2的密钥</h3><blockquote><p>第二个账号一定要重新命名，不然会覆盖掉第一个账号生成的密钥文件，使用-f参数指定文件名字</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f <span class="string">&quot;C:\Users\用户\.ssh/rsa_2&quot;</span> -C “邮箱2”</span><br></pre></td></tr></table></figure><ul><li>执行完会生成id_rsa_2(密钥)和id_rsa_2.pub(公钥)两个文件</li></ul><blockquote><p>ssh-keygen命令参数说明</p><ul><li>-t(type):指定要生成的密钥类型，有rsa1(SSH1),dsa(SSH2),ecdsa(SSH2),rsa(SSH2)等类型，较为常用的是rsa类型</li><li>-C comment：提供一个新的注释</li><li>-b bits：指定要生成的密钥长度 (单位:bit)，对于RSA类型的密钥，最小长度768bits,默认长度为2048bits。DSA密钥必须是1024bits</li><li>-f filename:指定生成的密钥文件名字</li></ul></blockquote><h2 id="0x02-将密钥添加至对应的GitHub账号"><a href="#0x02-将密钥添加至对应的GitHub账号" class="headerlink" title="0x02 将密钥添加至对应的GitHub账号"></a>0x02 将密钥添加至对应的GitHub账号</h2><ul><li><p>登录GitHub账号，找到在头像下方setting</p></li><li><p>其他如下图操作即可(从左至右)</p><p><img src="http://img-mikasa.test.upcdn.net//git/image-20210506215919195.png" alt="GitHub添加密钥"></p></li></ul><h2 id="0x03-编辑配置文件"><a href="#0x03-编辑配置文件" class="headerlink" title="0x03 编辑配置文件"></a>0x03 编辑配置文件</h2><ul><li>先确认.ssh文件夹中是否存在config文件，没有则创建一个(无文件后缀)</li><li>编辑如下内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Host:主机别名</span></span><br><span class="line"><span class="comment"># HostName:github服务器地址</span></span><br><span class="line"><span class="comment"># User:GitHub服务器用户名</span></span><br><span class="line"><span class="comment"># IdentityFile:和GitHub服务器通信的ssh私钥</span></span><br><span class="line"><span class="comment"># 通过IdentityFile可以区分不同的账号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 账号1的邮箱</span></span><br><span class="line">Host github_remmeiko</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile C:/Users/用户名/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 账号2的邮箱</span></span><br><span class="line">Host github_Mikasa  <span class="comment"># 前缀名可以任意设置</span></span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile C:/Users/用户名/.ssh/id_rsa_2</span><br></pre></td></tr></table></figure><blockquote><p>Host修改自己能够识别的名称即可</p><p>HostName设置为github.com和ssd.github.com都可以</p><p>IdentityFile为密钥所在的路径(注意寻找自己密钥所在的路径)</p><p>ps:如果实在找不到密钥所在路径，推荐下载everything软件查找</p><p><img src="http://img-mikasa.test.upcdn.net//git/image-20210507181236264.png" alt="Everything软件示例图"></p></blockquote><ul><li><p>上述操作成功之后就可以测试是否配置成功了</p><ul><li>终端输入以下命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github_remmeiko</span><br><span class="line">ssh -T git@github_Mikasa</span><br></pre></td></tr></table></figure><ul><li>显示以下内容则表示配置成功了</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi rem! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide  bash access.</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="0x04-使用ssh-agent管理密钥"><a href="#0x04-使用ssh-agent管理密钥" class="headerlink" title="0x04 使用ssh-agent管理密钥"></a>0x04 使用ssh-agent管理密钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-add id_rsa</span><br><span class="line">ssh-add id_rsa_2 </span><br><span class="line"><span class="comment"># 后面是生成的密钥</span></span><br></pre></td></tr></table></figure><h2 id="0x05-配置仓库设置"><a href="#0x05-配置仓库设置" class="headerlink" title="0x05 配置仓库设置"></a>0x05 配置仓库设置</h2><h3 id="1-删除全局配置"><a href="#1-删除全局配置" class="headerlink" title="1.删除全局配置"></a>1.删除全局配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> <span class="string">&#x27;user.name&#x27;</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> <span class="string">&#x27;user.email&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-设置本地配置"><a href="#2-设置本地配置" class="headerlink" title="2.设置本地配置"></a>2.设置本地配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name `用户名`</span><br><span class="line">git config user.email `邮箱@163.com`</span><br></pre></td></tr></table></figure><h2 id="0x06-本地仓库关联远程仓库"><a href="#0x06-本地仓库关联远程仓库" class="headerlink" title="0x06 本地仓库关联远程仓库"></a>0x06 本地仓库关联远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记住要到对应的本地仓库路径下执行对应的命令</span></span><br><span class="line">git remote add origin git@github_remmeiko:xxx/xxx.git</span><br><span class="line">git remote add origin git@github_Mikasa:xxx.xxx.git</span><br></pre></td></tr></table></figure><blockquote><p>　命令中后半段xxx/xxx.git就是下图中2标注的信息</p></blockquote><p><img src="http://img-mikasa.test.upcdn.net//git/image-20210507175641145.png"></p><h2 id="0x07-补充说明"><a href="#0x07-补充说明" class="headerlink" title="0x07 补充说明"></a>0x07 补充说明</h2><ul><li><p>关于账号和邮箱的说明</p><ul><li>我们一般接触的有两个地方的账号和邮箱，一个是git设置的账号邮箱，一个是GitHub账号对应的账号和邮箱</li><li>1）本地git设置账号和邮箱分为系统，全局和本地(local)，全局和系统是不随git库改变的，但是也可以为每个仓库设置单独的账号和邮箱。这个账号和邮箱不是作为验证信息，是作为commit提交记录相关信息的标识。</li></ul><blockquote><p>系统配置是对这台电脑所有用户生效的</p><p>全局配置是对该用户登录下的所有GitHub仓库生效的</p><p>本地(local)配置：也就是为单独仓库进行的配置，只对该仓库生效</p><p>优先级逐渐增加，譬如全局配置的优先级要低于仓库配置，就是说如果仓库和全局都设置了账号和邮箱，那么实际生效是仓库配置设置的账号和邮箱。</p></blockquote><blockquote><p><img src="http://img-mikasa.test.upcdn.net//git/image-20210507233902733.png" alt="git配置"></p></blockquote><ul><li>2）每个GitHub账号在注册时都会有一个对应的账号和邮箱，这个是GitHub的基本信息，说标识也可以，如下图</li></ul><blockquote><p><img src="http://img-mikasa.test.upcdn.net//git/image-20210507234533695.png" alt="GitHub账号配置"></p></blockquote><blockquote><p>前提说明：git设置的账号和邮箱下文将使用user.name和user.email代替</p></blockquote><ul><li>在本地git设置的user.name和uer.email作为commit记录时的一个标识，用来方便管理，可以清楚的知道是谁提交的。</li><li>当你的user.name和user.email和GitHub账号上的name\email一致，你提交修改时，github会自动将这两者关联起来，因此建议git设置的账号邮箱和GitHub账号邮箱一致，（随意填写也是可以的，但如果当两处的账号和邮箱不一致时，就无法进行统计，且头像变灰，而且你也可以改成其他人的账号和邮箱，记录就会显示是别人提交的)</li></ul><blockquote><p><img src="http://img-mikasa.test.upcdn.net//git/image-20210508003939061.png" alt="是否关联"></p></blockquote></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/liujiakunit/article/details/45849095">关于ssh-keygen命令的介绍与用法</a></p><p><a href="https://www.shenxt.info/post/2020-03-11-multi-github-in-one-pc/">如何在一台电脑上设置多个github账号</a></p><p><a href="https://www.jianshu.com/p/f3020c04d966">对Git用户名与Github账户关系的理解</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git 配置 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
